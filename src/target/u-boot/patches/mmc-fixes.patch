include/asm-arm/arch-s3c24x0/regs-sdi.h (S3C2410_SDIDCON_BLKNUM_MASK): typo,
  should be S3C2410_SDIDCNT_BLKNUM_MASK
cpu/arm920t/s3c24x0/mmc.c (mmc_block_read): use S3C2410_SDIDCON_BLKNUM instead
  of bogus S3C2410_SDIDCON_BLKNUM_MASK
cpu/arm920t/s3c24x0/mmc.c (mmc_block_read): check SDIDSTA after each FIFO read
  and clear any pending errors
cpu/arm920t/s3c24x0/mmc.c (mmc_block_read): commented out useless wait for
  S3C2410_SDIDSTA_XFERFINISH, added reset of S3C2410_SDIDSTA_XFERFINISH
cpu/arm920t/s3c24x0/mmc.c (mmc_cmd): removed unused variables "i" and "status"
cpu/arm920t/s3c24x0/mmc.c (mmc_init): removed unused variable "i" 
cpu/arm920t/s3c24x0/mmc.c (mmc_init): replaced MMC CID extraction with SD CID
  version
cpu/arm920t/s3c24x0/mmc.c (mmc_init): added casts to suppress warnings when
  using an "unsigned char *" buffer in sprintf
include/configs/neo1973.h (CONFIG_SUPPORT_VFAT): just #define, to avoid
  conflict with include/fat.h
cpu/arm920t/s3c24x0/mmc.c (rca): set this 16 bit value to 1, not 1 << 16

Index: u-boot/cpu/arm920t/s3c24x0/mmc.c
===================================================================
--- u-boot.orig/cpu/arm920t/s3c24x0/mmc.c
+++ u-boot/cpu/arm920t/s3c24x0/mmc.c
@@ -60,8 +60,6 @@ static int wide = 0;
 static u_int32_t *mmc_cmd(ushort cmd, ulong arg, ushort flags)
 {
 	static u_int32_t resp[5];
-	ulong status;
-	int i;
 
 	u_int32_t ccon, csta;
 	u_int32_t csta_rdy_bit = S3C2410_SDICMDSTAT_CMDSENT;
@@ -134,7 +132,7 @@ static int mmc_block_read(uchar *dst, ul
 	//sdi->SDIPRE = 0xff;
 
 	/* setup data */
-	dcon = (len >> 9) & S3C2410_SDIDCON_BLKNUM_MASK;
+	dcon = (len >> 9) & S3C2410_SDIDCON_BLKNUM;
 	dcon |= S3C2410_SDIDCON_BLOCKMODE;
 	dcon |= S3C2410_SDIDCON_RXAFTERCMD|S3C2410_SDIDCON_XFER_RXSTART;
 	if (wide)
@@ -145,16 +143,9 @@ static int mmc_block_read(uchar *dst, ul
 	resp = mmc_cmd(MMC_CMD_READ_BLOCK, src, CMD_F_RESP);
 
 	while (len > 0) {
-		u_int32_t sdidsta = sdi->SDIDSTA;
-		fifo = FIFO_FILL(sdi);
-		if (sdidsta & (S3C2410_SDIDSTA_FIFOFAIL|
-				S3C2410_SDIDSTA_CRCFAIL|
-				S3C2410_SDIDSTA_RXCRCFAIL|
-				S3C2410_SDIDSTA_DATATIMEOUT)) {
-			printf("mmc_block_read: err SDIDSTA=0x%08x\n", sdidsta);
-			return -EIO;
-		}
+		u_int32_t sdidsta, trouble;
 
+		fifo = FIFO_FILL(sdi);
 		while (fifo--) {
 			//debug("dst_u32 = 0x%08x\n", dst_u32);
 			*(dst_u32++) = sdi->SDIDAT;
@@ -165,16 +156,32 @@ static int mmc_block_read(uchar *dst, ul
 				break;
 			}
 		}
+
+		sdidsta = sdi->SDIDSTA;
+		trouble = sdidsta &
+			(S3C2410_SDIDSTA_FIFOFAIL |
+			S3C2410_SDIDSTA_CRCFAIL   |
+			S3C2410_SDIDSTA_RXCRCFAIL |
+			S3C2410_SDIDSTA_DATATIMEOUT);
+		if (trouble) {
+			printf("mmc_block_read: err SDIDSTA=0x%08x\n", sdidsta);
+			sdi->SDIDSTA |= trouble;
+			return -EIO;
+		}
 	}
 
+#if 0
 	debug("waiting for SDIDSTA  (currently 0x%08x\n", sdi->SDIDSTA);
 	while (!(sdi->SDIDSTA & (1 << 4))) {}
 	debug("done waiting for SDIDSTA (currently 0x%08x\n", sdi->SDIDSTA);
 
 	sdi->SDIDCON = 0;
+#endif
 
-	if (!(sdi->SDIDSTA & S3C2410_SDIDSTA_XFERFINISH))
+	if (!(sdi->SDIDSTA & S3C2410_SDIDSTA_XFERFINISH)) {
 		debug("mmc_block_read; transfer not finished!\n");
+		sdi->SDIDSTA |= S3C2410_SDIDSTA_XFERFINISH;
+	}
 
 	return 0;
 }
@@ -318,7 +325,9 @@ ulong mmc_bread(int dev_num, ulong blknr
 	return blkcnt;
 }
 
-static u_int16_t rca = MMC_DEFAULT_RCA;
+/* MMC_DEFAULT_RCA should probably be just 1, but this may break other code
+   that expects it to be shifted. */
+static u_int16_t rca = MMC_DEFAULT_RCA >> 16;
 
 static u_int32_t mmc_size(const struct mmc_csd *csd)
 {
@@ -331,6 +340,42 @@ static u_int32_t mmc_size(const struct m
 	return blocknr * block_len;
 }
 
+struct sd_cid {
+	char		pnm_0;	/* product name */
+	char		oid_1;	/* OEM/application ID */
+	char		oid_0;
+	uint8_t		mid;	/* manufacturer ID */
+	char		pnm_4;
+	char		pnm_3;
+	char		pnm_2;
+	char		pnm_1;
+	uint8_t		psn_2;	/* product serial number */
+	uint8_t		psn_1;
+	uint8_t		psn_0;	/* MSB */
+	uint8_t		prv;	/* product revision */
+	uint8_t		crc;	/* CRC7 checksum, b0 is unused and set to 1 */
+	uint8_t		mdt_1;	/* manufacturing date, LSB, RRRRyyyy yyyymmmm */
+	uint8_t		mdt_0;	/* MSB */
+	uint8_t		psn_3;	/* LSB */
+};
+
+static void print_cid(const struct sd_cid *cid)
+{
+	printf("Manufacturer:       0x%02x, OEM \"%c%c\"\n",
+	    cid->mid, cid->oid_0, cid->oid_1);
+	printf("Product name:       \"%c%c%c%c%c\", revision %d.%d\n",
+	    cid->pnm_0, cid->pnm_1, cid->pnm_2, cid->pnm_3, cid->pnm_4,
+	    cid->prv >> 4, cid->prv & 15);
+	printf("Serial number:      %u\n",
+	    cid->psn_0 << 24 | cid->psn_1 << 16 | cid->psn_2 << 8 |
+	    cid->psn_3);
+	printf("Manufacturing date: %d/%d\n",
+	    cid->mdt_1 & 15,
+	    2000+((cid->mdt_0 & 15) << 4)+((cid->mdt_1 & 0xf0) >> 4));
+	printf("CRC:                0x%02x, b0 = %d\n",
+	    cid->crc >> 1, cid->crc & 1);
+}
+
 int mmc_init(int verbose)
 {
  	int retries, rc = -ENODEV;
@@ -361,7 +406,6 @@ int mmc_init(int verbose)
 
 	printf("trying to detect SD Card...\n");
 	while (retries--) {
-		int i;
 		udelay(100000);
 		resp = mmc_cmd(55, 0x00000000, CMD_F_RESP);
 		resp = mmc_cmd(41, 0x00300000, CMD_F_RESP);
@@ -386,6 +430,7 @@ int mmc_init(int verbose)
 	/* try to get card id */
 	resp = mmc_cmd(MMC_CMD_ALL_SEND_CID, 0, CMD_F_RESP|CMD_F_RESP_LONG);
 	if (resp) {
+#if 0
 		/* TODO configure mmc driver depending on card attributes */
 		mmc_cid_t *cid = (mmc_cid_t *)resp;
 		if (verbose) {
@@ -400,6 +445,29 @@ int mmc_init(int verbose)
 			printf("Month = %d\n",cid->month);
 			printf("Year = %d\n",1997 + cid->year);
 		}
+		sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
+				cid->id[0], cid->id[1], cid->id[2],
+				cid->sn[0], cid->sn[1], cid->sn[2]);
+		sprintf(mmc_dev.product,"%s",cid->name);
+		sprintf(mmc_dev.revision,"%x %x",cid->hwrev, cid->fwrev);
+#else
+		struct sd_cid *cid = (struct sd_cid *) resp;
+
+		if (verbose)
+			print_cid((struct sd_cid *) resp);
+
+		sprintf((char *) mmc_dev.vendor,
+		    "Man %02 OEM %c%c \"%c%c%c%c%c\"",
+		    cid->mid, cid->oid_0, cid->oid_1,
+		    cid->pnm_0, cid->pnm_1, cid->pnm_2, cid->pnm_3,
+		    cid->pnm_4);
+		sprintf((char *) mmc_dev.product, "%d",
+		    cid->psn_0 << 24 | cid->psn_1 << 16 | cid->psn_2 << 8 |
+		    cid->psn_3);
+		sprintf((char *) mmc_dev.revision, "%d.%d",
+		    cid->prv >> 4, cid->prv & 15);
+#endif
+
 		/* fill in device description */
 		mmc_dev.if_type = IF_TYPE_MMC;
 		mmc_dev.part_type = PART_TYPE_DOS;
@@ -409,11 +477,6 @@ int mmc_init(int verbose)
 		/* FIXME fill in the correct size (is set to 32MByte) */
 		mmc_dev.blksz = 512;
 		mmc_dev.lba = 0x10000;
-		sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x",
-				cid->id[0], cid->id[1], cid->id[2],
-				cid->sn[0], cid->sn[1], cid->sn[2]);
-		sprintf(mmc_dev.product,"%s",cid->name);
-		sprintf(mmc_dev.revision,"%x %x",cid->hwrev, cid->fwrev);
 		mmc_dev.removable = 0;
 		mmc_dev.block_read = mmc_bread;
 
Index: u-boot/include/asm-arm/arch-s3c24x0/regs-sdi.h
===================================================================
--- u-boot.orig/include/asm-arm/arch-s3c24x0/regs-sdi.h
+++ u-boot/include/asm-arm/arch-s3c24x0/regs-sdi.h
@@ -62,7 +62,7 @@
 #define S3C2410_SDIDCON_XFER_RXSTART  (2<<12)
 #define S3C2410_SDIDCON_XFER_TXSTART  (3<<12)
 
-#define S3C2410_SDIDCON_BLKNUM_MASK   (0xFFF)
+#define S3C2410_SDIDCNT_BLKNUM_MASK   (0xFFF)
 #define S3C2410_SDIDCNT_BLKNUM_SHIFT  (12)
 
 #define S3C2410_SDIDSTA_RDYWAITREQ    (1<<10)
Index: u-boot/include/configs/neo1973.h
===================================================================
--- u-boot.orig/include/configs/neo1973.h
+++ u-boot/include/configs/neo1973.h
@@ -224,7 +224,7 @@
 #define CONFIG_EXT2		1
 
 #define CONFIG_FAT		1
-#define CONFIG_SUPPORT_VFAT	1
+#define CONFIG_SUPPORT_VFAT
 
 #if 1
 /* JFFS2 driver */
