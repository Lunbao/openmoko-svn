Add framebuffer and lcm support for GTA-02 to provide splash
Quick and dirty patch broadside-loads the Glamo registers
and changes the LCM SPI bitbang to go through the Glamo GPIO.

From power-on there is 3.5s of dark screen and then the
splash display is shown, which remains until Linux takes over.
Console is not enabled at the minute.

Fixes a bug where the Glamo was previously held in reset at
the time it was attempted to init the chip, this killed the
GTA-02 stone dead.

To get the best speed some code is added to manage the
splash action quite early in the boot --
In addition if a "splashimage" environment var exists it is
executed.  The one in current environment.in is wrong, it
needs to be

setenv splashimage nand read.e 0x32000000 splash 0x5000\; unzip 0x32000000 0x08800000 0x96000

The LCM post-reset deadtime is pipelined into the NAND
splash fetch for speed as well.

You need to have a gzipped splash bitmap in the splash part
with the current layout the DFU to set it looks like this

dfu-util -a 4 -d 0x1457:0x5119 -D splash.gz

Signed-off-by: Andy Green <andy@openmoko.com>

---

 board/neo1973/common/jbt6k74.c  |   23 +++
 board/neo1973/gta02/gta02.c     |   17 +-
 common/devices.c                |    1
 drivers/video/smedia3362.c      |  274 ++++++++++++++++++++++++---------------
 drivers/video/smedia3362.h      |   74 +++++++++++
 include/configs/neo1973_gta02.h |    6 -
 6 files changed, 274 insertions(+), 121 deletions(-)


Index: u-boot/board/neo1973/common/jbt6k74.c
===================================================================
--- u-boot.orig/board/neo1973/common/jbt6k74.c
+++ u-boot/board/neo1973/common/jbt6k74.c
@@ -95,6 +95,8 @@
 	[JBT_STATE_NORMAL]		= "normal",
 };
 
+#ifdef CONFIG_GTA01_REVISION
+
 #define GTA01_SCLK	(1 << 7) 	/* GPG7 */
 #define GTA01_MOSI	(1 << 6)	/* GPG6 */
 #define GTA01_MISO	(1 << 5)	/* GPG5 */
@@ -111,6 +113,20 @@
 #define SPI_SCL(bit)    if (bit) gpio->GPGDAT |=  GTA01_SCLK; \
 			else    gpio->GPGDAT &= ~GTA01_SCLK
 
+#else /* GTA02 */
+
+extern void smedia3362_spi_cs(int);
+extern void smedia3362_spi_sda(int);
+extern void smedia3362_spi_scl(int);
+extern void smedia3362_lcm_reset(int);
+
+#define SPI_CS(b)   smedia3362_spi_cs(b)
+#define SPI_SDA(b)  smedia3362_spi_sda(b)
+#define SPI_SCL(b)  smedia3362_spi_scl(b)
+
+#endif
+
+
 /* 150uS minimum clock cycle, we have two of this plus our other
  * instructions */
 #define SPI_DELAY	udelay(100)	/* 200uS */
@@ -298,6 +314,8 @@
 	/* Sleep mode off */
 	rc |= jbt_reg_write_nodata(jbt, JBT_REG_SLEEP_OUT);
 
+	/* at this point we have like 50% grey */
+
 	/* initialize register set */
 	rc |= jbt_init_regs(jbt);
 	return rc;
@@ -392,13 +410,16 @@
 {
 	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
 
+#ifdef CONFIG_GTA01_REVISION
 	/* initialize SPI for GPIO bitbang */
 	gpio->GPGCON &= 0xffff033f;
 	gpio->GPGCON |= 0x00005440;
 
 	/* get LCM out of reset */
 	gpio->GPCDAT |= (1 << 6);
-
+#else /* GTA02 */
+	smedia3362_lcm_reset(1);
+#endif
 	/* according to data sheet: wait 50ms (Tpos of LCM). However, 50ms
 	 * seems unreliable with later LCM batches, increasing to 90ms */
 	udelay(90000);
Index: u-boot/board/neo1973/gta02/gta02.c
===================================================================
--- u-boot.orig/board/neo1973/gta02/gta02.c
+++ u-boot/board/neo1973/gta02/gta02.c
@@ -188,6 +188,14 @@
 	gpio->GPJCON = 0x1551544;
 	gpio->GPJUP = 0x1ffff;
 	gpio->GPJDAT |= (1 << 4);	/* Set GPJ4 to high (nGSM_EN) */
+	gpio->GPJDAT &= ~(1 << 5);	/* Set GPJ5 to low 3D RST */
+	gpio->GPJDAT &= ~(1 << 5);	/* Set GPJ5 to low 3D RST */
+
+	/* leaving Glamo forced to Reset# active here killed
+	 * U-Boot when you touched the memory region
+	 */
+
+	gpio->GPJDAT |= (1 << 5);	/* Set GPJ5 to high 3D RST */
 #else
 #error Please define GTA02 version
 #endif
@@ -221,7 +229,7 @@
 
 	/* issue a short pulse with the vibrator */
 	neo1973_vibrator(1);
-	udelay(50000);
+	udelay(20000);
 	neo1973_vibrator(0);
 
 #if defined(CONFIG_ARCH_GTA02_v1)
@@ -231,10 +239,6 @@
 	udelay(50*1000);
 	pcf50633_reg_write(PCF50633_REG_DOWN2ENA, 0x2);
 	gpio->GPJDAT |= 0x000000001;	/* GTA02v1_GPIO_3D_RESET */
-#else
-	gpio->GPJDAT &= ~(1 << 5);	/* GTA02_GPIO_3D_RESET */
-	udelay(50*1000);
-	gpio->GPJDAT |= (1 << 5);	/* GTA02_GPIO_3D_RESET */
 #endif
 
 #if 0
@@ -292,9 +296,6 @@
 	jbt6k74_display_onoff(1);
 #endif
 
-	/* switch on the backlight */
-	neo1973_backlight(1);
-
 #if 0
 	{
 		/* check if sd card is inserted, and power-up if it is */
Index: u-boot/common/devices.c
===================================================================
--- u-boot.orig/common/devices.c
+++ u-boot/common/devices.c
@@ -204,7 +204,6 @@
 #ifdef CONFIG_NETCONSOLE
 	drv_nc_init ();
 #endif
-
 	return (0);
 }
 
Index: u-boot/drivers/video/smedia3362.c
===================================================================
--- u-boot.orig/drivers/video/smedia3362.c
+++ u-boot/drivers/video/smedia3362.c
@@ -26,6 +26,9 @@
 #include "videomodes.h"
 #include <s3c2410.h>
 #include "smedia3362.h"
+#ifdef CONFIG_GTA02_REVISION
+#include "../../board/neo1973/common/jbt6k74.h"
+#endif
 
 #define ARRAY_SIZE(x)           (sizeof(x) / sizeof((x)[0]))
 
@@ -34,134 +37,184 @@
 
 #define GLAMO_REG(x)	(*(volatile unsigned short *)(CONFIG_GLAMO_BASE + x))
 
-static inline void glamo_reg_write(u_int16_t reg, u_int16_t val)
+static inline void
+glamo_reg_write(u_int16_t reg, u_int16_t val)
 {
 	GLAMO_REG(reg) = val;
 }
 
-static inline u_int16_t glamo_reg_read(u_int16_t reg)
+static inline u_int16_t
+glamo_reg_read(u_int16_t reg)
 {
 	return GLAMO_REG(reg);
 }
 
-struct glamo_script {
-	u_int16_t reg;
-	u_int16_t val;
-}; // __attribute__((packed));
-
-/* from 'initial glamo 3365 script' */
-static struct glamo_script gl3362_init_script[] = {
-	/* clock */
-	{ GLAMO_REG_CLOCK_MEMORY, 	0x300a },
-	{ GLAMO_REG_CLOCK_LCD,		0x10aa },
-	{ GLAMO_REG_CLOCK_MMC,		0x100a },
-	{ GLAMO_REG_CLOCK_ISP,		0x32aa },
-	{ GLAMO_REG_CLOCK_JPEG,		0x100a },
-	{ GLAMO_REG_CLOCK_3D,		0x302a },
-	{ GLAMO_REG_CLOCK_2D,		0x302a },
-	//{ GLAMO_REG_CLOCK_RISC1,	0x1aaa },
-	//{ GLAMO_REG_CLOCK_RISC2,	0x002a },
-	{ GLAMO_REG_CLOCK_MPEG,		0x3aaa },
-	{ GLAMO_REG_CLOCK_MPROC,	0x12aa },
-		{ 0xfffe, 5 },
-	{ GLAMO_REG_CLOCK_HOST,		0x000d },
-	{ GLAMO_REG_CLOCK_MEMORY,	0x000a },
-	{ GLAMO_REG_CLOCK_LCD,		0x00ee },
-	{ GLAMO_REG_CLOCK_MMC,		0x000a },
-	{ GLAMO_REG_CLOCK_ISP,		0x02aa },
-	{ GLAMO_REG_CLOCK_JPEG,		0x000a },
-	{ GLAMO_REG_CLOCK_3D,		0x002a },
-	{ GLAMO_REG_CLOCK_2D,		0x002a },
-	//{ GLAMO_REG_CLOCK_RISC1,	0x0aaa },
-	//{ GLAMO_REG_CLOCK_RISC2,	0x002a },
-	{ GLAMO_REG_CLOCK_MPEG,		0x0aaa },
-	{ GLAMO_REG_CLOCK_MPROC,	0x02aa },
-		{ 0xfffe, 5 },
-	{ GLAMO_REG_PLL_GEN1,		0x061a }, /* PLL1=50MHz, OSCI=32kHz */
-	{ GLAMO_REG_PLL_GEN3,		0x09c3 }, /* PLL2=80MHz, OSCI=32kHz */
-		{ 0xfffe, 5 },
-	{ GLAMO_REG_CLOCK_GEN5_1,	0x18ff },
-	{ GLAMO_REG_CLOCK_GEN5_2,	0x051f },
-	{ GLAMO_REG_CLOCK_GEN6,		0x2000 },
-	{ GLAMO_REG_CLOCK_GEN7,		0x0105 },
-	{ GLAMO_REG_CLOCK_GEN8,		0x0100 },
-	{ GLAMO_REG_CLOCK_GEN10,	0x0017 },
-	{ GLAMO_REG_CLOCK_GEN11,	0x0017 },
-
-	/* hostbus interface */
-	{ GLAMO_REG_HOSTBUS(1),		0x0e00 },
-	{ GLAMO_REG_HOSTBUS(2),		0x07ff },
-	{ GLAMO_REG_HOSTBUS(4),		0x0080 },
-	{ GLAMO_REG_HOSTBUS(5),		0x0244 },
-	{ GLAMO_REG_HOSTBUS(6),		0x0600 },
-	{ GLAMO_REG_HOSTBUS(12),	0xf00e },
-
-	/* memory */
-	{ GLAMO_REG_MEM_TYPE,		0x0874 }, /* VRAM 8Mbyte */
-	{ GLAMO_REG_MEM_GEN,		0xafaf },
-	{ GLAMO_REG_MEM_TIMING(1),	0x0108 },
-	{ GLAMO_REG_MEM_TIMING(2),	0x0010 },
-	{ GLAMO_REG_MEM_TIMING(3),	0x0000 },
-	{ GLAMO_REG_MEM_TIMING(4),	0x0000 },
-	{ GLAMO_REG_MEM_TIMING(5),	0x0000 },
-	{ GLAMO_REG_MEM_TIMING(6),	0x0000 },
-	{ GLAMO_REG_MEM_TIMING(7),	0x0000 },
-	{ GLAMO_REG_MEM_TIMING(8),	0x1002 },
-	{ GLAMO_REG_MEM_TIMING(9),	0x6006 },
-	{ GLAMO_REG_MEM_TIMING(10),	0x00ff },
-	{ GLAMO_REG_MEM_TIMING(11),	0x0001 },
-	{ GLAMO_REG_MEM_POWER1,		0x0020 },
-	{ GLAMO_REG_MEM_POWER2,		0x0000 },
-	{ GLAMO_REG_MEM_DRAM1,		0x0000 },
-		{ 0xfffe, 1 },
-	{ GLAMO_REG_MEM_DRAM1,		0xc100 },
-	{ GLAMO_REG_MEM_DRAM2,		0x01d6 },
+/* these are called by jbt6k74 driver to do LCM bitbang SPI via Glamo */
+
+void smedia3362_spi_cs(int b)
+{
+	glamo_reg_write(GLAMO_REG_GPIO_GEN4,
+	(glamo_reg_read(GLAMO_REG_GPIO_GEN4) & 0xffef) | (b << 4));
+}
+
+void smedia3362_spi_sda(int b)
+{
+	glamo_reg_write(GLAMO_REG_GPIO_GEN3,
+		(glamo_reg_read(GLAMO_REG_GPIO_GEN3) & 0xff7f) | (b << 7));
+}
+
+void smedia3362_spi_scl(int b)
+{
+	glamo_reg_write(GLAMO_REG_GPIO_GEN3,
+		(glamo_reg_read(GLAMO_REG_GPIO_GEN3) & 0xffbf) | (b << 6));
+}
+
+void smedia3362_lcm_reset(int b)
+{
+	glamo_reg_write(GLAMO_REG_GPIO_GEN2,
+		(glamo_reg_read(GLAMO_REG_GPIO_GEN2) & 0xffef) | (b << 4));
+}
+
+/*
+ * these are dumps of Glamo register ranges from working Linux
+ * framebuffer
+ */
+static u16 u16a_lcd_init[] = {
+	0x0020, 0x1020, 0x0B40, 0x01E0, 0x0280, 0x440C, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x03C0, 0x0000, 0x0258, 0x0000,
+	0x0000, 0x0000, 0x0008, 0x0000, 0x0010, 0x0000, 0x01F0, 0x0000,
+	0x0294, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0004, 0x0000,
+	0x0284, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x8023, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 };
 
-#if 0
-static struct glamo_script gl3362_init_script[] = {
-	/* clock */
-	{ GLAMO_REG_CLOCK_MEMORY, 	0x300a },
+static u16 u16a_gen_init_0x0000[] = {
+	0x2020, 0x3650, 0x0002, 0x01FF, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x000D, 0x000B, 0x00EE, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x1839, 0x0000, 0x2000, 0x0101, 0x0100, 0x0000, 0x0000, 0x0000,
+	0x05DB, 0x5231, 0x09C3, 0x8261, 0x0003, 0x0000, 0x0000, 0x0000,
+	0x000F, 0x101E, 0xC0C3, 0x101E, 0x000F, 0x0001, 0x030F, 0x020F,
+	0x080F, 0x0F0F
 };
-#endif
 
-static void glamo_run_script(struct glamo_script *script, int num)
+static u16 u16a_gen_init_0x0200[] = {
+	0x0EF0, 0x07FF, 0x0000, 0x0080, 0x0344, 0x0600, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x4000, 0xF00E, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0, 0x00C0,
+	0x0873, 0xAFAF, 0x0108, 0x0010, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x0000, 0x1002, 0x6006, 0x00FF, 0x0001, 0x0020, 0x0000, 0x0000,
+	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+	0x3210, 0x5432, 0xE100, 0x01D6
+};
+
+#define glamofb_cmdq_empty() (glamo_reg_read(GLAMO_REGOFS_LCD + \
+					GLAMO_REG_LCD_STATUS1) & (1 << 15))
+
+void glamofb_cmd_mode(int on)
 {
-	int i;
-	for (i = 0; i < ARRAY_SIZE(gl3362_init_script); i++) {
-		struct glamo_script *reg = script + i;
-		printf("reg=0x%04x, val=0x%04x\n", reg->reg, reg->val);
-
-		if (reg->reg == 0xfffe)
-			udelay(reg->val*1000);
-		else
-			glamo_reg_write(reg->reg, reg->val);
+	if (on) {
+		while (!glamofb_cmdq_empty())
+			;
+		/* display the entire frame then switch to command */
+		glamo_reg_write(GLAMO_REGOFS_LCD + GLAMO_REG_LCD_COMMAND1,
+			  GLAMO_LCD_CMD_TYPE_DISP |
+			  GLAMO_LCD_CMD_DATA_FIRE_VSYNC);
+
+		while (!(glamo_reg_read(GLAMO_REGOFS_LCD +
+			 GLAMO_REG_LCD_STATUS2) & (1 << 12)))
+			;
+		udelay(5000); /* you really need this ;-) */
+	} else {
+		/* RGB interface needs vsync/hsync */
+		if (glamo_reg_read(GLAMO_REGOFS_LCD + GLAMO_REG_LCD_MODE3) &
+		    GLAMO_LCD_MODE3_RGB)
+			glamo_reg_write(GLAMO_REGOFS_LCD +
+				  GLAMO_REG_LCD_COMMAND1,
+				  GLAMO_LCD_CMD_TYPE_DISP |
+				  GLAMO_LCD_CMD_DATA_DISP_SYNC);
+
+		glamo_reg_write(GLAMO_REGOFS_LCD + GLAMO_REG_LCD_COMMAND1,
+			  GLAMO_LCD_CMD_TYPE_DISP |
+			  GLAMO_LCD_CMD_DATA_DISP_FIRE);
 	}
+}
 
+void glamofb_cmd_write(u_int16_t val)
+{
+	while (!glamofb_cmdq_empty())
+		;
+	glamo_reg_write(GLAMO_REGOFS_LCD + GLAMO_REG_LCD_COMMAND1, val);
 }
 
 static void glamo_core_init(void)
 {
-	printf("Glamo core device ID: 0x%04x, Revision 0x%04x\n",
-		glamo_reg_read(GLAMO_REG_DEVICE_ID),
-		glamo_reg_read(GLAMO_REG_REVISION_ID));
+	int bp;
 
-	glamo_run_script(gl3362_init_script, ARRAY_SIZE(gl3362_init_script));
+	/* power up PLL1 and PLL2 */
+	glamo_reg_write(GLAMO_REG_PLL_GEN7, 0x0000);
+	glamo_reg_write(GLAMO_REG_PLL_GEN3, 0x0400);
+
+	/* enable memory clock and get it out of deep pwrdown */
+	glamo_reg_write(GLAMO_REG_CLOCK_MEMORY,
+		glamo_reg_read(GLAMO_REG_CLOCK_MEMORY) |
+		GLAMO_CLOCK_MEM_EN_MOCACLK);
+	glamo_reg_write(GLAMO_REG_MEM_DRAM2,
+			glamo_reg_read(GLAMO_REG_MEM_DRAM2) &
+			(~GLAMO_MEM_DRAM2_DEEP_PWRDOWN));
+	glamo_reg_write(GLAMO_REG_MEM_DRAM1,
+			glamo_reg_read(GLAMO_REG_MEM_DRAM1) &
+			(~GLAMO_MEM_DRAM1_SELF_REFRESH));
+	/*
+	 * we just fill up the general hostbus and LCD register sets
+	 * with magic values taken from the Linux framebuffer init action
+	 */
+	for (bp = 0; bp < ARRAY_SIZE(u16a_gen_init_0x0000); bp++)
+		glamo_reg_write(GLAMO_REGOFS_GENERIC | (bp << 1),
+				u16a_gen_init_0x0000[bp]);
+
+	for (bp = 0; bp < ARRAY_SIZE(u16a_gen_init_0x0200); bp++)
+		glamo_reg_write(GLAMO_REGOFS_HOSTBUS | (bp << 1),
+				u16a_gen_init_0x0200[bp]);
+	
+	/* spin until PLL1 lock */
+	while (!(glamo_reg_read(GLAMO_REG_PLL_GEN5) & 1))
+		;
+
+	glamofb_cmd_mode(1);
+	/* LCD registers */
+	for (bp = 0; bp < ARRAY_SIZE(u16a_lcd_init); bp++)
+		glamo_reg_write(GLAMO_REGOFS_LCD + (bp << 1),
+			u16a_lcd_init[bp]);
+	glamofb_cmd_mode(0);
 }
 
-void *video_hw_init(void)
+void * video_hw_init(void)
 {
-	u_int16_t reg;
 	GraphicDevice *pGD = (GraphicDevice *)&smi;
 
-	glamo_core_init();
-
-	printf("Video: ");
+	printf("Glamo core device ID: 0x%04x, Revision 0x%04x\n",
+		glamo_reg_read(GLAMO_REG_DEVICE_ID),
+		glamo_reg_read(GLAMO_REG_REVISION_ID));
 
-	/* FIXME: returning since vram access still locks up system */
-	return NULL;
+	glamo_core_init();
 
-	/* FIXME: this is static */
 	pGD->winSizeX = pGD->plnSizeX = 480;
 	pGD->winSizeY = pGD->plnSizeY = 640;
 	pGD->gdfBytesPP = 2;
@@ -170,16 +223,21 @@
 	pGD->frameAdrs = CONFIG_GLAMO_BASE + 0x00800000;
 	pGD->memSize = 0x200000; /* 480x640x16bit = 614400 bytes */
 
-	//printf("memset ");
-	//memset(pGD->frameAdrs, 0, pGD->memSize);
-
-	printf("END\n");
+#ifdef CONFIG_GTA02_REVISION
+	/* bring up the LCM */
+	smedia3362_lcm_reset(1);
+	if (getenv("splashimage"))
+		run_command(getenv("splashimage"), 0);
+	jbt6k74_enter_state(JBT_STATE_NORMAL);
+	jbt6k74_display_onoff(1);
+	/* switch on the backlight */
+	neo1973_backlight(1);
+#endif
 
 	return &smi;
 }
 
-void
-video_set_lut(unsigned int index, unsigned char r,
+void video_set_lut(unsigned int index, unsigned char r,
 	      unsigned char g, unsigned char b)
 {
 	/* FIXME: we don't support any palletized formats */
Index: u-boot/drivers/video/smedia3362.h
===================================================================
--- u-boot.orig/drivers/video/smedia3362.h
+++ u-boot/drivers/video/smedia3362.h
@@ -101,6 +101,42 @@
 	GLAMO_REG_PLL_GEN7	= 0x01f0,
 };
 
+enum glamo_reg_mem_dram1 {
+	GLAMO_MEM_DRAM1_EN_SDRAM_CLK	= (1 << 11),
+	GLAMO_MEM_DRAM1_SELF_REFRESH	= (1 << 12),
+};
+
+enum glamo_reg_mem_dram2 {
+	GLAMO_MEM_DRAM2_DEEP_PWRDOWN	= (1 << 12),
+};
+
+enum glamo_reg_clock51 {
+	GLAMO_CLOCK_GEN51_EN_DIV_MCLK	= 0x0001,
+	GLAMO_CLOCK_GEN51_EN_DIV_SCLK	= 0x0002,
+	GLAMO_CLOCK_GEN51_EN_DIV_JCLK	= 0x0004,
+	GLAMO_CLOCK_GEN51_EN_DIV_DCLK	= 0x0008,
+	GLAMO_CLOCK_GEN51_EN_DIV_DMCLK	= 0x0010,
+	GLAMO_CLOCK_GEN51_EN_DIV_DHCLK	= 0x0020,
+	GLAMO_CLOCK_GEN51_EN_DIV_GCLK	= 0x0040,
+	GLAMO_CLOCK_GEN51_EN_DIV_TCLK	= 0x0080,
+	/* FIXME: higher bits */
+};
+
+enum glamo_reg_hostbus2 {
+	GLAMO_HOSTBUS2_MMIO_EN_ISP	= 0x0001,
+	GLAMO_HOSTBUS2_MMIO_EN_JPEG	= 0x0002,
+	GLAMO_HOSTBUS2_MMIO_EN_MPEG	= 0x0004,
+	GLAMO_HOSTBUS2_MMIO_EN_LCD	= 0x0008,
+	GLAMO_HOSTBUS2_MMIO_EN_MMC	= 0x0010,
+	GLAMO_HOSTBUS2_MMIO_EN_MICROP0	= 0x0020,
+	GLAMO_HOSTBUS2_MMIO_EN_MICROP1	= 0x0040,
+	GLAMO_HOSTBUS2_MMIO_EN_CQ	= 0x0080,
+	GLAMO_HOSTBUS2_MMIO_EN_RISC	= 0x0100,
+	GLAMO_HOSTBUS2_MMIO_EN_2D	= 0x0200,
+	GLAMO_HOSTBUS2_MMIO_EN_3D	= 0x0400,
+};
+
+
 #define GLAMO_REG_HOSTBUS(x)	(GLAMO_REGOFS_HOSTBUS-2+(x*2))
 
 #define REG_MEM(x)		(GLAMO_REGOFS_MEMORY+(x))
@@ -330,6 +366,7 @@
 	GLAMO_REG_LCD_SRAM_DRIVING3	= REG_LCD(0x164),
 };
 
+
 enum glamo_reg_lcd_mode1 {
 	GLAMO_LCD_MODE1_PWRSAVE		= 0x0001,
 	GLAMO_LCD_MODE1_PARTIAL_PRT	= 0x0002,
@@ -382,4 +419,41 @@
 	GLAMO_LCD_MODE3_18BITS		= 0x0040,
 };
 
+enum glamo_lcd_cmd_type {
+	GLAMO_LCD_CMD_TYPE_DISP		= 0x0000,
+	GLAMO_LCD_CMD_TYPE_PARALLEL	= 0x4000,
+	GLAMO_LCD_CMD_TYPE_SERIAL	= 0x8000,
+	GLAMO_LCD_CMD_TYPE_SERIAL_DIRECT= 0xc000,
+};
+#define GLAMO_LCD_CMD_TYPE_MASK		0xc000
+
+enum glamo_lcd_cmds {
+	GLAMO_LCD_CMD_DATA_DISP_FIRE	= 0x00,
+	GLAMO_LCD_CMD_DATA_DISP_SYNC	= 0x01,		/* RGB only */
+	/* switch to command mode, no display */
+	GLAMO_LCD_CMD_DATA_FIRE_NO_DISP	= 0x02,
+	/* display until VSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_VSYNC	= 0x11,
+	/* display until HSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_HSYNC	= 0x12,
+	/* display until VSYNC, 1 black frame, VSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_VSYNC_B	= 0x13,
+	/* don't care about display and switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_FREE	= 0x14,		/* RGB only */
+	/* don't care about display, keep data display but disable data,
+	 * and switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_FREE_D	= 0x15,		/* RGB only */
+};
+
+enum glamo_reg_clock_2d {
+	GLAMO_CLOCK_2D_DG_GCLK		= 0x0001,
+	GLAMO_CLOCK_2D_EN_GCLK		= 0x0002,
+	GLAMO_CLOCK_2D_DG_M7CLK		= 0x0004,
+	GLAMO_CLOCK_2D_EN_M7CLK		= 0x0008,
+	GLAMO_CLOCK_2D_DG_M6CLK		= 0x0010,
+	GLAMO_CLOCK_2D_EN_M6CLK		= 0x0020,
+	GLAMO_CLOCK_2D_RESET		= 0x1000,
+	GLAMO_CLOCK_2D_CQ_RESET		= 0x2000,
+};
+
 #endif /* _GLAMO_REGS_H */
Index: u-boot/include/configs/neo1973_gta02.h
===================================================================
--- u-boot.orig/include/configs/neo1973_gta02.h
+++ u-boot/include/configs/neo1973_gta02.h
@@ -250,12 +250,12 @@
 /* we have a board_late_init() function */
 #define BOARD_LATE_INIT			1
 
-#if 0
+#if 1
 #define CONFIG_VIDEO
 #define CONFIG_VIDEO_GLAMO3362
 #define CONFIG_CFB_CONSOLE
-#define CONFIG_VIDEO_LOGO
-#define CONFIG_SPLASH_SCREEN
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_SPLASH_SCREEN
 #define CFG_VIDEO_LOGO_MAX_SIZE	(640*480+1024+100) /* 100 = slack */
 #define CONFIG_VIDEO_BMP_GZIP
 #define CONFIG_VGA_AS_SINGLE_DEVICE
