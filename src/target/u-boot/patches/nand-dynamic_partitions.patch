This patch adds support for 'dynamic partitions'.  This basically 
works as follows:
* The nand code generates a bad-block-table at the first scan of the chip
* The dynamic partition code calculates the raw partition sizes based on 
  the bad block table.  E.g. if you have a partition of size 0x30000, and there are 
  two bad blocks (0x4000 each) in it, the raw size will increase to 0x38000, and the
  following partitions get shifted towards the end of flash.

Please note that currently the desired partition sizes are stored at compile-time
in an array in drivers/nand/nand_bbt.c, so this definitely needs to change before
submitting/merging upstream.

In order to calculate the partiton map (and set mtdparts accordingly), you can use
the 'dynpart' command at the prompt.  Use 'saveenv' to make the setting permanent.

Signed-off-by: Harald Welte <laforge@openmoko.org>

Index: u-boot/drivers/nand/nand_bbt.c
===================================================================
--- u-boot.orig/drivers/nand/nand_bbt.c	2007-02-25 15:36:10.000000000 +0100
+++ u-boot/drivers/nand/nand_bbt.c	2007-02-25 15:36:51.000000000 +0100
@@ -1044,9 +1044,70 @@
 	switch ((int)res) {
 	case 0x00:	return 0;
 	case 0x01:	return 1;
+	case 0x03:	return 1;
 	case 0x02:	return allowbbt ? 0 : 1;
 	}
 	return 1;
 }
 
+#define ARRAY_SIZE(x)           (sizeof(x) / sizeof((x)[0]))
+
+
+/* NOTE: this is extremely device-dependent, so it shouldn't really be here.
+   The sum of all part_size[]s must equal to the NAND size, i.e., 0x4000000.
+   "initrd" is sized such that it can hold two uncompressed 16 bit 640*480
+   images: 640*480*2*2 = 1228800 < 1245184. */
+
+static unsigned int part_size[] = {
+    CFG_UBOOT_SIZE, 0x4000, 0x200000, 0xa0000, 0x3d5c000-CFG_UBOOT_SIZE };
+static char *part_names[] = {
+    "u-boot", "u-boot_env", "kernel", "splash", "rootfs" };
+
+int nand_create_mtd_dynpart(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	int part;
+	char *mtdparts;
+	unsigned int cur_offs = 0;
+
+	mtdparts = malloc(512); /* FIXME: bounds checking */
+	if (!mtdparts)
+		return -ENOMEM;
+
+	memset(mtdparts, 0, sizeof(mtdparts));
+	sprintf(mtdparts, "mtdparts=neo1973-nand:");
+
+	for (part = 0; part < ARRAY_SIZE(part_size); part++) {
+		unsigned int bb_delta = 0;
+		unsigned int offs = 0;
+		char mtdpart[32];
+		for (offs = cur_offs; offs < cur_offs + part_size[part] + bb_delta;
+		     offs += this->erasesize) {
+			int block = (int) (offs >> (this->bbt_erase_shift - 1));
+			u_int8_t bbt = (this->bbt[block >> 3] >> (block & 0x06)) & 0x03;
+			if (bbt == 0x03)
+				bb_delta += this->erasesize;
+		}
+
+		if (cur_offs + part_size[part] + bb_delta > this->chipsize)
+			part_size[part] = this->chipsize - cur_offs - bb_delta;
+#if 0
+		printf("partition %u: start = 0x%08x, end=%08x size=%08x, size_inc_bb=%08x\n",
+			part, cur_offs, cur_offs + part_size[part] + bb_delta,
+			part_size[part], part_size[part] + bb_delta);
+#endif
+		cur_offs += part_size[part] + bb_delta;
+		sprintf(mtdpart, "0x%.8x(%.16s),", part_size[part] + bb_delta, part_names[part]);
+		mtdpart[sizeof(mtdpart)-1] = '\0';
+		strncat(mtdparts, mtdpart, sizeof(mtdparts)-strlen(mtdparts)-1);
+	}
+
+	mtdparts[strlen(mtdparts)-1] = '\0';
+	printf("mtdparts %s\n", mtdparts);
+	setenv("mtdparts", mtdparts);
+
+	free(mtdparts);
+	return 0;
+}
+
 #endif
Index: u-boot/include/configs/neo1973.h
===================================================================
--- u-boot.orig/include/configs/neo1973.h	2007-02-25 15:36:18.000000000 +0100
+++ u-boot/include/configs/neo1973.h	2007-02-25 15:36:51.000000000 +0100
@@ -99,7 +99,7 @@
 			CFG_CMD_ELF	 | \
 			CFG_CMD_MISC	 | \
 			/* CFG_CMD_USB	 | */ \
-			/* CFG_CMD_JFFS2	 | */ \
+			CFG_CMD_JFFS2	 | \
 			CFG_CMD_DIAG	 | \
 			/* CFG_CMD_HWFLOW	 | */ \
 			CFG_CMD_SAVES	 | \
@@ -209,13 +209,13 @@
 #define CONFIG_FAT		1
 #define CONFIG_SUPPORT_VFAT	1
 
-#if 0
+#if 1
 /* JFFS2 driver */
 #define CONFIG_JFFS2_CMDLINE	1
 #define CONFIG_JFFS2_NAND	1
 #define CONFIG_JFFS2_NAND_DEV	0
-#define CONFIG_JFFS2_NAND_OFF	0x634000
-#define CONFIG_JFFS2_NAND_SIZE	0x39cc000
+//#define CONFIG_JFFS2_NAND_OFF	0x634000
+//#define CONFIG_JFFS2_NAND_SIZE	0x39cc000
 #endif
 
 /* ATAG configuration */
@@ -251,4 +251,7 @@
 
 #define CONFIG_S3C2410_NAND_BBT                1
 
+#define MTDIDS_DEFAULT	"nand0=neo1973-nand"
+#define MTPARTS_DEFAULT	"neo1973-nand:256k(u-boot),16k(u-boot_env),2M(kernel),640k(splash),-(jffs2)"
+
 #endif	/* __CONFIG_H */
Index: u-boot/common/cmd_jffs2.c
===================================================================
--- u-boot.orig/common/cmd_jffs2.c	2007-02-25 15:36:10.000000000 +0100
+++ u-boot/common/cmd_jffs2.c	2007-02-25 15:36:18.000000000 +0100
@@ -1841,6 +1841,29 @@
 	return NULL;
 }
 
+/* Return the 'net size' of the partition (i.e. excluding any bad blocks) */
+unsigned int nand_net_part_size(struct part_info *part)
+{
+	struct mtd_info *mtd;
+	unsigned int offs;
+	unsigned int bb_delta = 0;
+
+	if (!part || !part->dev || !part->dev->id ||
+	    part->dev->id->num >= CFG_MAX_NAND_DEVICE)
+		return 0;
+
+ 	mtd = &nand_info[part->dev->id->num];
+
+	for (offs = part->offset; offs < part->offset + part->size;
+	     offs += mtd->erasesize) {
+		if (nand_isbad_bbt(mtd, offs, 0))
+			bb_delta += mtd->erasesize;
+	}
+
+	return part->size - bb_delta;
+}
+
+
 /***************************************************/
 /* U-boot commands				   */
 /***************************************************/
@@ -2132,6 +2155,20 @@
 	printf ("Usage:\n%s\n", cmdtp->usage);
 	return 1;
 }
+
+extern int nand_create_mtd_dynpart(struct mtd_info *mtd);
+
+int do_dynpart(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+#if 0
+	int i = simple_strtoul(argv[1], NULL, 0);
+	if (i >= CFG_MAX_NAND_DEVICE)
+		return -EINVAL;
+#endif
+	nand_create_mtd_dynpart(&nand_info[0]);
+
+	return 0;
+}
 #endif /* #ifdef CONFIG_JFFS2_CMDLINE */
 
 /***************************************************/
@@ -2197,6 +2234,13 @@
 	"<name>     := '(' NAME ')'\n"
 	"<ro-flag>  := when set to 'ro' makes partition read-only (not used, passed to kernel)\n"
 );
+
+U_BOOT_CMD(
+	dynpart, 1,	1,	do_dynpart,
+	"dynpart\t- dynamically calculate partition table based on BBT\n",
+	"\n"
+	"    - sets 'mtdparts' according to BBT\n");
+
 #endif /* #ifdef CONFIG_JFFS2_CMDLINE */
 
 /***************************************************/
Index: u-boot/common/cmd_nand.c
===================================================================
--- u-boot.orig/common/cmd_nand.c	2007-02-25 15:36:10.000000000 +0100
+++ u-boot/common/cmd_nand.c	2007-02-25 15:36:50.000000000 +0100
@@ -101,7 +101,7 @@
 }
 
 int
-arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size)
+arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off, ulong *size, int net)
 {
 	int idx = nand_curr_device;
 #if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
@@ -122,10 +122,17 @@
 					printf("'%s' is not a number\n", argv[1]);
 					return -1;
 				}
-				if (*size > part->size)
-					*size = part->size;
+				if (*size > part->size) {
+					if (net)
+						*size = nand_net_part_size(part);
+					else
+						*size = part->size;
+				}
 			} else {
-				*size = part->size;
+				if (net)
+					*size = nand_net_part_size(part);
+				else
+					*size = part->size;
 			}
 			idx = dev->id->num;
 			*nand = nand_info[idx];
@@ -261,7 +268,7 @@
 
 		printf("\nNAND %s: ", scrub ? "scrub" : "erase");
 		/* skip first two or three arguments, look for offset and size */
-		if (arg_off_size(argc - o, argv + o, nand, &off, &size) != 0)
+		if (arg_off_size(argc - o, argv + o, nand, &off, &size, 0) != 0)
 			return 1;
 
 		memset(&opts, 0, sizeof(opts));
@@ -323,7 +330,7 @@
 
 		read = strncmp(cmd, "read", 4) == 0; /* 1 = read, 0 = write */
 		printf("\nNAND %s: ", read ? "read" : "write");
-		if (arg_off_size(argc - 3, argv + 3, nand, &off, &size) != 0)
+		if (arg_off_size(argc - 3, argv + 3, nand, &off, &size, 1) != 0)
 			return 1;
 
 		s = strchr(cmd, '.');
@@ -445,7 +452,7 @@
 	}
 
 	if (strcmp(cmd, "unlock") == 0) {
-		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size) < 0)
+		if (arg_off_size(argc - 2, argv + 2, nand, &off, &size, 0) < 0)
 			return 1;
 
 		if (!nand_unlock(nand, off, size)) {
Index: u-boot/common/cmd_dynenv.c
===================================================================
--- u-boot.orig/common/cmd_dynenv.c	2007-02-25 15:37:32.000000000 +0100
+++ u-boot/common/cmd_dynenv.c	2007-02-25 15:37:39.000000000 +0100
@@ -60,7 +60,7 @@
 		buf[2] = 'V';
 		buf[3] = '0';
 
-		if (arg_off_size(argc-2, argv+2, mtd, &addr, &dummy) < 0) {
+		if (arg_off_size(argc-2, argv+2, mtd, &addr, &dummy, 1) < 0) {
 			printf("Offset or partition name expected\n");
 			goto fail;
 		}
Index: u-boot/include/util.h
===================================================================
--- u-boot.orig/include/util.h	2007-02-25 15:37:43.000000000 +0100
+++ u-boot/include/util.h	2007-02-25 15:37:49.000000000 +0100
@@ -28,6 +28,6 @@
 
 /* common/cmd_nand.c */
 int arg_off_size(int argc, char *argv[], nand_info_t *nand, ulong *off,
-  ulong *size);
+  ulong *size, int net);
 
 #endif /* UTIL_H */
