board/neo1973/bootmenu.c: simple configurable boot menu
board/neo1973/neo1973.c (neo1973_new_second): return 1 if a new second has
  started since the last call
board/neo1973/neo1973.c (neo1973_on_key_pressed): return 1 if the $POWER key is
  pressed
board/neo1973/neo1973.c (board_late_init): make use of neo1973_new_second and
  neo1973_on_key_pressed
board/neo1973/neo1973.h: added function prototypes
u-boot/board/neo1973/neo1973.c (board_late_init): enter the boot menu when 
  "AUX" was pressed at least half the time
u-boot/board/neo1973/neo1973.c (board_late_init): minor code cleanup
u-boot/common/console.c, include/console.h: added "console_poll_hook" to be
  called when waiting for console in put in "getc" and "tstc"
board/neo1973/neo1973.c (board_late_init): poll for the boot menu also on RAM
  boot, reset, or unknown cause
board/neo1973/neo1973.c (board_late_init): don't look for the power key if
  woken up by the charger

- Werner Almesberger <werner@openmoko.org>

Index: u-boot/board/neo1973/bootmenu.c
===================================================================
--- /dev/null
+++ u-boot/board/neo1973/bootmenu.c
@@ -0,0 +1,366 @@
+/*
+ * bootmenu.c - Boot menu
+ *
+ * Copyright (C) 2006-2007 by OpenMoko, Inc.
+ * Written by Werner Almesberger <werner@openmoko.org>
+ * All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#include <common.h>
+#include <devices.h>
+#include <console.h>
+#include <environment.h>
+#include <environment.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_USBD_DFU
+#include "usbdcore.h"
+#include "usb_dfu.h"
+#endif
+
+#include "neo1973.h"
+
+
+#define ANSI_CLEAR	"\e[2J"
+#define ANSI_REVERSE	"\e[7m"
+#define	ANSI_NORMAL	"\e[m"
+#define ANSI_GOTOYX	"\e[%d;%dH"
+
+#define DEBOUNCE_LOOPS		1000	/* wild guess */
+
+/*
+ * MIN_BOOT_MENU_TIMEOUT ensures that users can't by accident set the timeout
+ * unusably short.
+ */
+#define MIN_BOOT_MENU_TIMEOUT	10	/* 10 seconds */
+#define BOOT_MENU_TIMEOUT	60	/* 60 seconds */
+#define AFTER_COMMAND_WAIT	3	/* wait (2,3] after running commands */
+#define	MAX_MENU_ITEMS		10	/* cut off after that many */
+
+#define BOOT_TXT	"Boot"
+#define	FACTORY_TXT	"Factory reset"
+
+
+/*
+ * The menu options are indexed as follows:
+ *
+ * 0		Hard-coded "Boot"
+ * n		User-provided options
+ * options+1	Hard-coded "Factory reset"
+ *
+ * "options" is the number of user-provided options. They are stored in
+ * environment variables names "menu_N", starting with 1.
+ *
+ * Because there can be * holes in the sequence of "menu_N" variables, we use
+ * map[] to map the option number to the number in the variable name. The
+ * first variable goes into map[1], etc., so that, if we start with menu_1 and
+ * have no holes, map[i] == i for 1 <= i <= options.
+ */
+
+static int map[MAX_MENU_ITEMS];
+static int options = 0;
+static int width = sizeof(FACTORY_TXT)-1;
+
+static device_t *bm_con;
+
+
+static void bm_printf(const char *fmt, ...)
+{
+	va_list args;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start(args, fmt);
+	vsprintf(printbuffer, fmt, args);
+	va_end(args);
+
+	bm_con->puts(printbuffer);
+}
+
+
+static int debounce(int (*fn)(void), int last)
+{
+	int on, i;
+
+again:
+	on = fn();
+	if (on != last)
+		for (i = DEBOUNCE_LOOPS; i; i--)
+			if (on != fn())
+				goto again;
+	return on;
+}
+
+
+static char *get_option(int n)
+{
+	char name[] = "menu_XX";
+
+	sprintf(name+5,"%d",map[n]);
+	return getenv(name);
+}
+
+
+static void print_option_n(int n)
+{
+	char *s, *colon;
+	int len;
+
+	if (!n) {
+		bm_printf("  %-*s  ", width, BOOT_TXT);
+		return;
+	}
+	if (n == options+1) {
+		bm_printf("  %-*s  ", width, FACTORY_TXT);
+		return;
+	}
+	s = get_option(n);
+    	if (!s)
+		return;
+	colon = strchr(s, ':');
+	if (colon)
+		*colon = 0;
+	len = strlen(s);
+	if (len > width)
+		width = len;
+	bm_printf("  %-*s  ", width, s);
+	if (colon)
+		*colon = ':';
+}
+
+
+static void print_option(int n, int reverse)
+{
+	bm_printf(ANSI_GOTOYX, n+4, 1);
+	if (reverse)
+		bm_printf(ANSI_REVERSE);
+	print_option_n(n);
+	if (reverse)
+		bm_printf(ANSI_NORMAL);
+}
+
+
+static const char *option_command(int n)
+{
+	const char *s, *colon;
+
+	s = get_option(n);
+	if (!s)
+		return NULL;
+	colon = strchr(s, ':');
+	return colon ? colon+1 : s;
+}
+
+
+static int get_var_positive_int(char *var, int default_value)
+{
+	const char *s;
+	char *end;
+	int n;
+
+	s = getenv(var);
+	if (!s)
+		return default_value;
+        n = simple_strtoul(s, &end, 0);
+	if (!*s || *end || n < 1)
+		return default_value;
+	return n;
+}
+
+
+static void init_bootmenu(void)
+{
+	int n;
+
+	bm_printf(ANSI_CLEAR ANSI_GOTOYX "*** BOOT MENU ***\n\n", 2, 1);
+	options = 0;
+
+	/* hard-coded first option */
+	print_option(0, 1);
+	map[0] = 0;
+
+	/* user-provided options */
+	for (n = 1; n != MAX_MENU_ITEMS+1; n++) {
+		map[options+1] = n;
+		if (option_command(options+1)) {
+			options++;
+			print_option(options, 0);
+		}
+	}
+
+	/* hard-coded last option */
+	print_option(options+1, 0);
+	map[options+1] = options+1;
+
+	bm_printf("\n\nPress [AUX] to select, [POWER] to execute.\n");
+}
+
+
+static void redirect_console(int grab)
+{
+	static device_t *orig_stdout, *orig_stderr;
+
+	if (grab) {
+		orig_stdout = stdio_devices[stdout];
+		orig_stderr = stdio_devices[stderr];
+		stdio_devices[stdout] = bm_con;
+		stdio_devices[stderr] = bm_con;
+	}
+	else {
+		/*
+		 * Make this conditional, because the command may also change
+		 * the console.
+		 */
+		if (stdio_devices[stdout] == bm_con)
+			stdio_devices[stdout] = orig_stdout;
+		if (stdio_devices[stderr] == bm_con)
+			stdio_devices[stderr] = orig_stderr;
+	}
+}
+
+
+static int system_idle(void)
+{
+#ifdef  CONFIG_USBD_DFU
+	if (system_dfu_state)
+		return *system_dfu_state == DFU_STATE_appIDLE;
+#endif
+	return 1;
+}
+
+
+static void poweroff_if_idle(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (system_idle())
+		neo1973_poweroff();
+	local_irq_restore(flags);
+}
+
+
+static void do_option(int option)
+{
+	int seconds, aux;
+
+	bm_printf(ANSI_CLEAR ANSI_GOTOYX, 1, 1);
+	redirect_console(1);
+	if (!option || option == options+1) {
+		if (option) {
+			default_env();
+			run_command("dynpart", 0);
+		}
+		run_command("bootd", 0);
+	}
+	else
+		run_command(option_command(option), 0);
+	redirect_console(0);
+	seconds = get_var_positive_int("after_command_wait",
+	    AFTER_COMMAND_WAIT);
+	if (seconds)
+		bm_printf("\nPress [AUX] to %s.",
+		    option ? "return to boot menu" : "power off");
+	aux = 1; /* require up-down transition */
+	while (seconds) {
+		int tmp;
+
+		tmp = debounce(neo1973_911_key_pressed, aux);
+		if (tmp && !aux)
+			break;
+		aux = tmp;
+		if (neo1973_new_second())
+			seconds--;
+	}
+	if (!option)
+		poweroff_if_idle();
+	init_bootmenu();
+}
+
+
+static void bootmenu_hook(int activity)
+{
+	static int aux = 1, on = 1;
+	static int option = 0;
+	static int seconds = 0;
+	int tmp;
+
+	if (activity)
+		seconds = 0;
+	tmp = debounce(neo1973_911_key_pressed, aux);
+	if (tmp && !aux) {
+		print_option(option, 0);
+		option++;
+		if (option == options+2)
+			option = 0;
+		print_option(option, 1);
+		seconds = 0;
+	}
+	aux = tmp;
+	tmp = debounce(neo1973_on_key_pressed, on);
+	if (tmp && !on) {
+		do_option(option);
+		option = 0;
+		seconds = 0;
+	}
+	on = tmp;
+	if (neo1973_new_second()) {
+		int timeout;
+
+		timeout = get_var_positive_int("boot_menu_timeout",
+		    BOOT_MENU_TIMEOUT);
+		if (timeout < MIN_BOOT_MENU_TIMEOUT)
+			timeout = MIN_BOOT_MENU_TIMEOUT;
+		if (++seconds > timeout) {
+			poweroff_if_idle();
+			seconds = 0;
+		}
+	}
+}
+
+
+static device_t *find_console(const char *name)
+{
+	int i;
+
+	for (i = 1; i != ListNumItems(devlist); i++) {
+		device_t *dev = ListGetPtrToItem(devlist, i);
+
+		if (!strcmp(name, dev->name))
+			if (dev->flags & DEV_FLAGS_OUTPUT)
+				return dev;
+	}
+	return NULL;
+}
+
+
+void bootmenu(void)
+{
+	bm_con = find_console("vga");
+	if (bm_con && bm_con->start && bm_con->start() < 0)
+		bm_con = NULL;
+	if (!bm_con)
+		bm_con = stdio_devices[stdout];
+	if (!bm_con)
+		return;
+#if 0
+	console_assign(stdout, "vga");
+	console_assign(stderr, "vga");
+#endif
+	init_bootmenu();
+	console_poll_hook = bootmenu_hook;
+}
Index: u-boot/board/neo1973/neo1973.c
===================================================================
--- u-boot.orig/board/neo1973/neo1973.c
+++ u-boot/board/neo1973/neo1973.c
@@ -196,10 +196,15 @@ int board_late_init(void)
 	extern unsigned char booted_from_nand;
 	unsigned char tmp;
 	char buf[32];
+	int menu_vote = 0; /* <= 0: no, > 0: yes */
+	int seconds = 0;
 
 	/* Initialize the Power Management Unit with a safe register set */
 	pcf50606_init();
 
+	/* if there's no other reason, must be regular reset */
+	neo1973_wakeup_cause = NEO1973_WAKEUP_RESET;
+
 	if (!booted_from_nand)
 		goto woken_by_reset;
 
@@ -209,45 +214,41 @@ int board_late_init(void)
 	setenv("pcf50606_int1", buf);
 
 	if (tmp & PCF50606_INT1_ALARM) {
-		/* we've been woken up by RTC alarm or charger insert, boot */
+		/* we've been woken up by RTC alarm, boot */
 		neo1973_wakeup_cause = NEO1973_WAKEUP_ALARM;
 		goto continue_boot;
 	}
 	if (tmp & PCF50606_INT1_EXTONR) {
+		/* we've been woken up by charger insert */
 		neo1973_wakeup_cause = NEO1973_WAKEUP_CHARGER;
 	}
 
 	if (tmp & PCF50606_INT1_ONKEYF) {
-		int seconds = 0;
-		neo1973_wakeup_cause = NEO1973_WAKEUP_POWER_KEY;
 		/* we've been woken up by a falling edge of the onkey */
+		neo1973_wakeup_cause = NEO1973_WAKEUP_POWER_KEY;
+	}
 
-		/* we can't just setenv(bootdelay,-1) because that would
-		 * accidentially become permanent if the user does saveenv */
-		if (neo1973_911_key_pressed())
-			nobootdelay = 1;
-
-		while (1) {
-			u_int8_t int1, oocs;
-
-			oocs = pcf50606_reg_read(PCF50606_REG_OOCS);
-			if (oocs & PFC50606_OOCS_ONKEY)
-				break;
-
-			int1 = pcf50606_reg_read(PCF50606_REG_INT1);
-			if (int1 & PCF50606_INT1_SECOND)
-				seconds++;
-
-			if (seconds >= POWER_KEY_SECONDS)
-				goto continue_boot;
-		}
-		/* Power off if minimum number of seconds not reached */
-		neo1973_poweroff();
+	if (neo1973_wakeup_cause == NEO1973_WAKEUP_CHARGER) {
+		/* if we still think it was only a charger insert, boot */
+		goto continue_boot;
 	}
 
 woken_by_reset:
-	/* if there's no other reason, must be regular reset */
-	neo1973_wakeup_cause = NEO1973_WAKEUP_RESET;
+
+	while (neo1973_wakeup_cause == NEO1973_WAKEUP_RESET ||
+	    neo1973_on_key_pressed()) {
+		if (neo1973_911_key_pressed())
+			menu_vote++;
+		else
+			menu_vote--;
+
+		if (neo1973_new_second())
+			seconds++;
+		if (seconds >= POWER_KEY_SECONDS)
+			goto continue_boot;
+	}
+	/* Power off if minimum number of seconds not reached */
+	neo1973_poweroff();
 
 continue_boot:
 	jbt6k74_init();
@@ -262,6 +263,11 @@ continue_boot:
 	/* switch on the backlight */
 	neo1973_backlight(1);
 
+	if (menu_vote > 0) {
+		bootmenu();
+		nobootdelay = 1;
+	}
+
 	return 0;
 }
 
@@ -313,6 +319,16 @@ void neo1973_vibrator(int on)
 		gpio->GPBDAT &= ~(1 << 10);
 }
 
+int neo1973_new_second(void)
+{
+	return pcf50606_reg_read(PCF50606_REG_INT1) & PCF50606_INT1_SECOND;
+}
+
+int neo1973_on_key_pressed(void)
+{
+	return !(pcf50606_reg_read(PCF50606_REG_OOCS) & PFC50606_OOCS_ONKEY);
+}
+
 int neo1973_911_key_pressed(void)
 {
 	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
Index: u-boot/board/neo1973/Makefile
===================================================================
--- u-boot.orig/board/neo1973/Makefile
+++ u-boot/board/neo1973/Makefile
@@ -25,7 +25,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= lib$(BOARD).a
 
-OBJS	:= neo1973.o pcf50606.o cmd_neo1973.o jbt6k74.o
+OBJS	:= neo1973.o pcf50606.o cmd_neo1973.o jbt6k74.o bootmenu.o
 SOBJS	:= lowlevel_init.o
 
 .PHONY:	all
Index: u-boot/board/neo1973/neo1973.h
===================================================================
--- u-boot.orig/board/neo1973/neo1973.h
+++ u-boot/board/neo1973/neo1973.h
@@ -15,4 +15,10 @@ void neo1973_poweroff(void);
 void neo1973_backlight(int on);
 void neo1973_vibrator(int on);
 
+int neo1973_new_second(void);
+int neo1973_on_key_pressed(void);
+int neo1973_911_key_pressed(void);
+
+void bootmenu(void);
+
 #endif
Index: u-boot/common/console.c
===================================================================
--- u-boot.orig/common/console.c
+++ u-boot/common/console.c
@@ -160,8 +160,12 @@ void fprintf (int file, const char *fmt,
 
 /** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/
 
+void (*console_poll_hook)(int activity);
+
 int getc (void)
 {
+	while (console_poll_hook && !tstc());
+
 	if (gd->flags & GD_FLG_DEVINIT) {
 		/* Get from the standard input */
 		return fgetc (stdin);
@@ -171,7 +175,7 @@ int getc (void)
 	return serial_getc ();
 }
 
-int tstc (void)
+static int do_tstc (void)
 {
 	if (gd->flags & GD_FLG_DEVINIT) {
 		/* Test the standard input */
@@ -182,6 +186,16 @@ int tstc (void)
 	return serial_tstc ();
 }
 
+int tstc (void)
+{
+	int ret;
+
+	ret = do_tstc();
+	if (console_poll_hook)
+		console_poll_hook(ret);
+	return ret;
+}
+
 void putc (const char c)
 {
 #ifdef CONFIG_SILENT_CONSOLE
Index: u-boot/include/console.h
===================================================================
--- u-boot.orig/include/console.h
+++ u-boot/include/console.h
@@ -33,6 +33,8 @@
 extern device_t	*stdio_devices[] ;
 extern char *stdio_names[MAX_FILES] ;
 
+extern void (*console_poll_hook)(int activity);
+
 int console_realloc(int top);
 
 #endif
