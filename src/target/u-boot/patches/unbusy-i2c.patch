board/neo1973/gta01/gta01.c: added logic to detect pending PMU interrupts
board/neo1973/gta01/gta01.c (neo1973_new_second, neo1973_on_key_pressed): only
  poll PMU if there is a pending interrupt
board/neo1973/gta01/pcf50606.c (pcf50606_initial_regs): cleared (unmasked)
  SECONDM in INT1M

- Werner Almesberger <werner@openmoko.org>

Index: u-boot/board/neo1973/gta01/gta01.c
===================================================================
--- u-boot.orig/board/neo1973/gta01/gta01.c
+++ u-boot/board/neo1973/gta01/gta01.c
@@ -439,19 +439,60 @@ void neo1973_gps(int on)
 	printf("not implemented yet!\n");
 }
 
+static int pwr_int_pending(void)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+#if defined(CONFIG_ARCH_GTA01B_v4)
+	return !(gpio->GPGDAT & (1 << 1));	/* EINT9/GPG1 */
+#else
+	return !(gpio->GPGDAT & (1 << 8));	/* EINT16/GPG8 */
+#endif /* !CONFIG_ARCH_GTA01B_v4 */
+}
+
+static int have_int1(uint8_t mask)
+{
+	static uint8_t pending = 0;
+
+	if (pwr_int_pending()) {
+		/*
+		 * We retrieve all interupts, so that we clear any stray ones
+		 * in INT2 and INT3.
+		 */
+		uint8_t int1,int2,int3;
+
+		int1 = pcf50606_reg_read(PCF50606_REG_INT1);
+		int2 = pcf50606_reg_read(PCF50606_REG_INT2);
+		int3 = pcf50606_reg_read(PCF50606_REG_INT3);
+		pending |= int1;
+	}
+	if (!(pending & mask))
+		return 0;
+	pending &= ~mask;
+	return 1;
+}
+
 int neo1973_new_second(void)
 {
-	return pcf50606_reg_read(PCF50606_REG_INT1) & PCF50606_INT1_SECOND;
+	return have_int1(PCF50606_INT1_SECOND);
 }
 
 int neo1973_on_key_pressed(void)
 {
-	return !(pcf50606_reg_read(PCF50606_REG_OOCS) & PFC50606_OOCS_ONKEY);
+	static int pressed = -1;
+
+	if (pressed == -1 ||
+	    have_int1(PCF50606_INT1_ONKEYF | PCF50606_INT1_ONKEYR)) {
+		pressed = !(pcf50606_reg_read(PCF50606_REG_OOCS) &
+		     PFC50606_OOCS_ONKEY);
+}
+	return pressed;
 }
 
 int neo1973_aux_key_pressed(void)
 {
 	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
 	if (gpio->GPFDAT & (1 << 6))
 		return 0;
 	return 1;
Index: u-boot/board/neo1973/gta01/pcf50606.c
===================================================================
--- u-boot.orig/board/neo1973/gta01/pcf50606.c
+++ u-boot/board/neo1973/gta01/pcf50606.c
@@ -6,7 +6,7 @@
 const u_int8_t pcf50606_initial_regs[__NUM_PCF50606_REGS] = {
 	[PCF50606_REG_OOCS] 	= 0x00,
 	/* gap */
-	[PCF50606_REG_INT1M]	= PCF50606_INT1_SECOND,
+	[PCF50606_REG_INT1M]	= 0x00,
 	[PCF50606_REG_INT2M]	= 0x00,
 	[PCF50606_REG_INT3M]	= PCF50606_INT3_TSCPRES,
 	[PCF50606_REG_OOCC1] 	= PCF50606_OOCC1_RTCWAK |
Index: u-boot/board/neo1973/gta02/gta02.c
===================================================================
--- u-boot.orig/board/neo1973/gta02/gta02.c
+++ u-boot/board/neo1973/gta02/gta02.c
@@ -396,15 +396,55 @@ void neo1973_gps(int on)
 		pcf50633_reg_write(PCF50633_REG_LDO5ENA, 0x00);
 }
 
+static int pwr_int_pending(void)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+
+	return !(gpio->GPGDAT & (1 << 1));	/* EINT9/GPG1 */
+}
+
+static int have_int(uint8_t mask1, uint8_t mask2)
+{
+	static uint8_t pending1 = 0, pending2 = 0;
+
+	if (pwr_int_pending()) {
+		/*
+		 * We retrieve all interupts, so that we clear any stray ones
+		 * in INT2 and INT3.
+		 */
+		uint8_t ints[5];
+		int i;
+
+		for (i = 0; i != 5; i++)
+			ints[i] = pcf50633_reg_read(PCF50633_REG_INT1+i);
+		pending1 |= ints[0];
+		pending2 |= ints[1];
+	}
+	if (pending1 & mask1) {
+		pending1 &= ~mask1;
+		return 1;
+	}
+	if (pending2 & mask2) {
+		pending1 &= ~mask2;
+		return 1;
+	}
+	return 0;
+}
+
 int neo1973_new_second(void)
 {
-	return pcf50633_reg_read(PCF50633_REG_INT1) & PCF50633_INT1_SECOND;
+	return have_int(PCF50633_INT1_SECOND, 0);
 }
 
 int neo1973_on_key_pressed(void)
 {
-	return !(pcf50633_reg_read(PCF50633_REG_OOCSTAT)
-						& PCF50633_OOCSTAT_ONKEY);
+	static int pressed = -1;
+
+	if (pressed == -1 ||
+	    have_int(0, PCF50633_INT2_ONKEYF | PCF50633_INT2_ONKEYR))
+		pressed = !(pcf50633_reg_read(PCF50633_REG_OOCSTAT) &
+		    PCF50633_OOCSTAT_ONKEY);
+	return pressed;
 }
 
 int neo1973_aux_key_pressed(void)
Index: u-boot/board/neo1973/gta02/pcf50633.c
===================================================================
--- u-boot.orig/board/neo1973/gta02/pcf50633.c
+++ u-boot/board/neo1973/gta02/pcf50633.c
@@ -5,13 +5,11 @@
 /* initial register set for PCF50633 in Neo1973 GTA02 devices */
 const u_int8_t pcf50633_initial_regs[__NUM_PCF50633_REGS] = {
 	/* gap */
-	[PCF50633_REG_INT1M]	= PCF50633_INT1_SECOND,
+	[PCF50633_REG_INT1M]	= 0x00,
 	[PCF50633_REG_INT2M]	= PCF50633_INT2_EXTON3F |
 				  PCF50633_INT2_EXTON3R |
 				  PCF50633_INT2_EXTON2F |
-				  PCF50633_INT2_EXTON2R |
-				  PCF50633_INT2_EXTON1R |
-				  PCF50633_INT2_EXTON1F,
+				  PCF50633_INT2_EXTON2R,
 	[PCF50633_REG_INT3M]	= PCF50633_INT3_ADCRDY,
 	[PCF50633_REG_INT4M]	= 0x00,
 	[PCF50633_REG_INT5M]	= 0x00,
