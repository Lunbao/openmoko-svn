This patch adds a new 'neo1973' command that can be used to control backlight,
charger and power-off.

Signed-off-by: Harald Welte <laforge@openmoko.org>

Index: u-boot/board/neo1973/Makefile
===================================================================
--- u-boot.orig/board/neo1973/Makefile	2007-02-15 00:43:51.000000000 +0100
+++ u-boot/board/neo1973/Makefile	2007-02-15 01:36:20.000000000 +0100
@@ -25,7 +25,7 @@
 
 LIB	= lib$(BOARD).a
 
-OBJS	:= neo1973.o
+OBJS	:= neo1973.o pcf50606.o cmd_neo1973.o
 SOBJS	:= lowlevel_init.o
 
 $(LIB):	$(OBJS) $(SOBJS)
Index: u-boot/board/neo1973/cmd_neo1973.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/board/neo1973/cmd_neo1973.c	2007-02-15 01:55:42.000000000 +0100
@@ -0,0 +1,120 @@
+/*
+ * (C) Copyright 2006 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Boot support
+ */
+#include <common.h>
+#include <command.h>
+#include <net.h>		/* for print_IPaddr */
+#include <s3c2410.h>
+
+#include "neo1973.h"
+#include "pcf50606.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#if (CONFIG_COMMANDS & CFG_CMD_BDI)
+
+static const char *chgstate_names[] = {
+	[PCF50606_MBCC1_CHGMOD_QUAL]		= "qualification",
+	[PCF50606_MBCC1_CHGMOD_PRE]		= "pre",
+	[PCF50606_MBCC1_CHGMOD_TRICKLE]		= "trickle",
+	[PCF50606_MBCC1_CHGMOD_FAST_CCCV]	= "fast_cccv",
+	[PCF50606_MBCC1_CHGMOD_FAST_NOCC]	= "fast_nocc",
+	[PCF50606_MBCC1_CHGMOD_FAST_NOCV]	= "fast_nocv",
+	[PCF50606_MBCC1_CHGMOD_FAST_SW]		= "fast_switch",
+	[PCF50606_MBCC1_CHGMOD_IDLE]		= "idle",
+};
+
+int do_neo1973 ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int i;
+
+	if (!strcmp(argv[1], "info")) {
+		printf("FIC GTA01 Hardware Revision 0x%04x\n", get_board_rev());
+	} else if (!strcmp(argv[1], "power-off")) {
+		neo1973_poweroff();
+	} else if (!strcmp(argv[1], "charger") || !strcmp(argv[1], "charge")) {
+		if (argc < 3)
+			goto out_help;
+		if (!strcmp(argv[2], "status") || !strcmp(argv[2], "state")) {
+			u_int8_t mbcc1 = pcf50606_reg_read(PCF50606_REG_MBCC1);
+			u_int8_t chgmod = (mbcc1 & PCF50606_MBCC1_CHGMOD_MASK);
+			printf("%s\n", chgstate_names[chgmod]);
+		} else if (!strcmp(argv[2], "autofast")) {
+			pcf50606_reg_set_bit_mask(PCF50606_REG_MBCC1,
+						  PCF50606_MBCC1_AUTOFST,
+						  PCF50606_MBCC1_AUTOFST);
+		} else if (!strcmp(argv[2], "!autofast")) {
+			pcf50606_reg_set_bit_mask(PCF50606_REG_MBCC1,
+						  PCF50606_MBCC1_AUTOFST, 0);
+		} else if (!strcmp(argv[2], "off")) {
+			pcf50606_reg_set_bit_mask(PCF50606_REG_MBCC1,
+						  PCF50606_MBCC1_CHGMOD_MASK,
+						  PCF50606_MBCC1_CHGMOD_IDLE);
+		} else if (!strcmp(argv[2], "fast")) {
+			pcf50606_reg_set_bit_mask(PCF50606_REG_MBCC1,
+						  PCF50606_MBCC1_CHGMOD_MASK,
+						  PCF50606_MBCC1_CHGMOD_FAST_CCCV);
+		} else
+			goto out_help;
+	} else if (!strcmp(argv[1], "backlight")) {
+		if (argc < 3)
+			goto out_help;
+		if (!strcmp(argv[2], "on"))
+			neo1973_backlight(1);
+		else
+			neo1973_backlight(0);
+	} else if (!strcmp(argv[1], "vibrator")) {
+		if (argc < 3)
+			goto out_help;
+		if (!strcmp(argv[2], "on"))
+			neo1973_vibrator(1);
+		else
+			neo1973_vibrator(0);
+	} else {
+out_help:
+		printf("Usage:\n%s\n", cmdtp->usage);
+		return 1;
+	}
+
+	return 0;
+}
+
+/* -------------------------------------------------------------------- */
+
+U_BOOT_CMD(
+	neo1973,	4,	1,	do_neo1973,
+	"neo1973 - phone specific commands\n",
+	"neo1973 info - display phone informantion\n"
+	"neo1973 power-off - switch off the phone\n"
+	"neo1973 charger status - display charger status\n"
+	"neo1973 charger autofast - enable automatic fast (500mA) charging\n"
+	"neo1973 charger !autofast - disable automatic fast (500mA) charging\n"
+	"neo1973 charger fast - enable fast (500mA) charging\n"
+	"neo1973 charger off - disable charging\n"
+	"neo1973 backlight (on|off) - switch backlight on or off\n"
+	"neo1973 vibrator (on|off) - switch vibrator on or off\n"
+);
+#endif	/* CFG_CMD_BDI */
Index: u-boot/board/neo1973/neo1973.c
===================================================================
--- u-boot.orig/board/neo1973/neo1973.c	2007-02-15 00:43:51.000000000 +0100
+++ u-boot/board/neo1973/neo1973.c	2007-02-15 01:36:20.000000000 +0100
@@ -34,8 +34,14 @@
 #include <s3c2410.h>
 #include <i2c.h>
 
+#include "neo1973.h"
+#include "pcf50606.h"
+
 DECLARE_GLOBAL_DATA_PTR;
 
+/* That many seconds the power key needs to be pressed to power up */
+#define POWER_KEY_SECONDS	2
+
 #if defined(CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
 //#define M_MDIV	0xA1		/* Fout = 202.8MHz */
 //#define M_PDIV	0x3
@@ -61,6 +67,9 @@
 #define U_M_PDIV	0x2
 #define U_M_SDIV	0x3
 
+unsigned int neo1973_wakeup_cause;
+extern int nobootdelay;
+
 static inline void delay (unsigned long loops)
 {
 	__asm__ volatile ("1:\n"
@@ -96,7 +105,7 @@
 #if defined(CONFIG_ARCH_GTA01_v3)
 	gpio->GPACON = 0x007FFFFF;
 
-	gpio->GPBCON = 0x00005056;
+	gpio->GPBCON = 0x00005055;
 	gpio->GPBUP = 0x000007FF;
 
 	gpio->GPCCON = 0xAAAA12A8;
@@ -119,7 +128,7 @@
 #elif defined(CONFIG_ARCH_GTA01_v4)
 	gpio->GPACON = 0x005E47FF;
 
-	gpio->GPBCON = 0x00045016;
+	gpio->GPBCON = 0x00045015;
 	gpio->GPBUP = 0x000007FF;
 	gpio->GPBDAT |= 0x4;		/* Set GBP2 to high (Flash power-up) */
 
@@ -143,7 +152,7 @@
 #elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
 	gpio->GPACON = 0x005E47FF;
 
-	gpio->GPBCON = 0x00145416;
+	gpio->GPBCON = 0x00145415;
 	gpio->GPBUP = 0x000007FF;
 	gpio->GPBDAT |= 0x4;		/* Set GBP2 to high (Flash power-up) */
 
@@ -184,26 +193,65 @@
 int board_late_init(void)
 {
 	unsigned char tmp;
+	char buf[32];
 
-	tmp = 0x17; /* charge backup battery with 100uA during ACTIVE+STANDBY*/
-	i2c_write(0x08, 0x2d, 1, &tmp, 1);
+	/* Initialize the Power Management Unit with a safe register set */
+	pcf50606_init();
 
-	tmp = 0x1a; /* 4.2V battery, precharge 0.1*Ifast */
-	i2c_write(0x08, 0x2b, 1, &tmp, 1);
+	/* obtain wake-up reason, save INT1 in environment */
+	tmp = pcf50606_reg_read(PCF50606_REG_INT1);
+	sprintf(buf, "0x%02x", tmp);
+	setenv("pcf50606_int1", buf);
+
+	if (tmp & PCF50606_INT1_ALARM) {
+		/* we've been woken up by RTC alarm or charger insert, boot */
+		neo1973_wakeup_cause = NEO1973_WAKEUP_ALARM;
+		goto continue_boot;
+	}
+	if (tmp & PCF50606_INT1_EXTONR) {
+		neo1973_wakeup_cause = NEO1973_WAKEUP_CHARGER;
+	}
+
+	if (tmp & PCF50606_INT1_ONKEYF) {
+		int seconds = 0;
+		neo1973_wakeup_cause = NEO1973_WAKEUP_POWER_KEY;
+		/* we've been woken up by a falling edge of the onkey */
+
+		/* we can't just setenv(bootdelay,-1) because that would
+		 * accidentially become permanent if the user does saveenv */
+		if (neo1973_911_key_pressed())
+			nobootdelay = 1;
+
+		while (1) {
+			u_int8_t int1, oocs;
+
+			oocs = pcf50606_reg_read(PCF50606_REG_OOCS);
+			if (oocs & PFC50606_OOCS_ONKEY)
+				break;
+
+			int1 = pcf50606_reg_read(PCF50606_REG_INT1);
+			if (int1 & PCF50606_INT1_SECOND)
+				seconds++;
+
+			if (seconds >= POWER_KEY_SECONDS)
+				goto continue_boot;
+		}
+		/* Power off if minimum number of seconds not reached */
+		neo1973_poweroff();
+	}
+
+	/* if there's no other reason, must be regular reset */
+	neo1973_wakeup_cause = NEO1973_WAKEUP_RESET;
+
+continue_boot:
+	/* issue a short pulse with the vibrator */
+	neo1973_vibrator(1);
+	udelay(50000);
+	neo1973_vibrator(0);
 
-	tmp = 0x0f; /* CHGAPE | AUTOFST | fast charge */
-	i2c_write(0x08, 0x29, 1, &tmp, 1);
+	/* switch on the backlight */
+	neo1973_backlight(1);
 
-#if defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
-	tmp = 0xe4;	/* CPU Voltage: 2.1V */
-	i2c_write(0x08, 0x21, 1, &tmp, 1);
-#endif
-
-#if defined(CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
-	const char mmc_power = 0x8f;
-	/* enable D2REG 3.3V (SC/MMC power) */
-	i2c_write(0x08, 0x25, 1, &mmc_power, 1);
-#endif
 	return 0;
 }
 
@@ -227,3 +275,38 @@
 	return 0x00000230;
 #endif
 }
+
+void neo1973_poweroff(void)
+{
+	serial_printf("poweroff\n");
+	udc_disconnect();
+	pcf50606_reg_write(PCF50606_REG_OOCC1, PCF50606_OOCC1_GOSTDBY);
+	/* don't return to caller */
+	while (1) ;
+}
+
+void neo1973_backlight(int on)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	if (on)
+		gpio->GPBDAT |= 0x01;
+	else
+		gpio->GPBDAT &= ~0x01;
+}
+
+void neo1973_vibrator(int on)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	if (on)
+		gpio->GPBDAT |= (1 << 10);
+	else
+		gpio->GPBDAT &= ~(1 << 10);
+}
+
+int neo1973_911_key_pressed(void)
+{
+	S3C24X0_GPIO * const gpio = S3C24X0_GetBase_GPIO();
+	if (gpio->GPFDAT & (1 << 6))
+		return 0;
+	return 1;
+}
Index: u-boot/board/neo1973/pcf50606.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/board/neo1973/pcf50606.h	2007-02-15 00:43:54.000000000 +0100
@@ -0,0 +1,267 @@
+#ifndef _PCF50606_H
+#define _PCF50606_H
+
+/* Philips PCF50606 Power Managemnt Unit (PMU) driver
+ * (C) 2006-2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ */
+
+enum pfc50606_regs {
+	PCF50606_REG_ID		= 0x00,
+	PCF50606_REG_OOCS	= 0x01,
+	PCF50606_REG_INT1	= 0x02,	/* Interrupt Status */
+	PCF50606_REG_INT2	= 0x03,	/* Interrupt Status */
+	PCF50606_REG_INT3	= 0x04,	/* Interrupt Status */
+	PCF50606_REG_INT1M	= 0x05,	/* Interrupt Mask */
+	PCF50606_REG_INT2M	= 0x06,	/* Interrupt Mask */
+	PCF50606_REG_INT3M	= 0x07,	/* Interrupt Mask */
+	PCF50606_REG_OOCC1	= 0x08,
+	PCF50606_REG_OOCC2	= 0x09,
+	PCF50606_REG_RTCSC	= 0x0a,	/* Second */
+	PCF50606_REG_RTCMN	= 0x0b,	/* Minute */
+	PCF50606_REG_RTCHR	= 0x0c,	/* Hour */
+	PCF50606_REG_RTCWD	= 0x0d,	/* Weekday */
+	PCF50606_REG_RTCDT	= 0x0e,	/* Day */
+	PCF50606_REG_RTCMT	= 0x0f,	/* Month */
+	PCF50606_REG_RTCYR	= 0x10,	/* Year */
+	PCF50606_REG_RTCSCA	= 0x11, /* Alarm Second */
+	PCF50606_REG_RTCMNA	= 0x12, /* Alarm Minute */
+	PCF50606_REG_RTCHRA	= 0x13, /* Alarm Hour */
+	PCF50606_REG_RTCWDA	= 0x14, /* Alarm Weekday */
+	PCF50606_REG_RTCDTA	= 0x15, /* Alarm Day */
+	PCF50606_REG_RTCMTA	= 0x16, /* Alarm Month */
+	PCF50606_REG_RTCYRA	= 0x17, /* Alarm Year */
+	PCF50606_REG_PSSC	= 0x18,	/* Power sequencing */
+	PCF50606_REG_PWROKM	= 0x19,	/* PWROK mask */
+	PCF50606_REG_PWROKS	= 0x1a,	/* PWROK status */
+	PCF50606_REG_DCDC1	= 0x1b,
+	PCF50606_REG_DCDC2	= 0x1c,
+	PCF50606_REG_DCDC3	= 0x1d,
+	PCF50606_REG_DCDC4	= 0x1e,
+	PCF50606_REG_DCDEC1	= 0x1f,
+	PCF50606_REG_DCDEC2	= 0x20,
+	PCF50606_REG_DCUDC1	= 0x21,
+	PCF50606_REG_DCUDC2	= 0x22,
+	PCF50606_REG_IOREGC	= 0x23,
+	PCF50606_REG_D1REGC1	= 0x24,
+	PCF50606_REG_D2REGC1	= 0x25,
+	PCF50606_REG_D3REGC1	= 0x26,
+	PCF50606_REG_LPREGC1	= 0x27,
+	PCF50606_REG_LPREGC2	= 0x28,
+	PCF50606_REG_MBCC1	= 0x29,
+	PCF50606_REG_MBCC2	= 0x2a,
+	PCF50606_REG_MBCC3	= 0x2b,
+	PCF50606_REG_MBCS1	= 0x2c,
+	PCF50606_REG_BBCC	= 0x2d,
+	PCF50606_REG_ADCC1	= 0x2e,
+	PCF50606_REG_ADCC2	= 0x2f,
+	PCF50606_REG_ADCS1	= 0x30,
+	PCF50606_REG_ADCS2	= 0x31,
+	PCF50606_REG_ADCS3	= 0x32,
+	PCF50606_REG_ACDC1	= 0x33,
+	PCF50606_REG_BVMC	= 0x34,
+	PCF50606_REG_PWMC1	= 0x35,
+	PCF50606_REG_LEDC1	= 0x36,
+	PCF50606_REG_LEDC2	= 0x37,
+	PCF50606_REG_GPOC1	= 0x38,
+	PCF50606_REG_GPOC2	= 0x39,
+	PCF50606_REG_GPOC3	= 0x3a,
+	PCF50606_REG_GPOC4	= 0x3b,
+	PCF50606_REG_GPOC5	= 0x3c,
+	__NUM_PCF50606_REGS
+};
+
+enum pcf50606_reg_oocs {
+	PFC50606_OOCS_ONKEY	= 0x01,
+	PCF50606_OOCS_EXTON	= 0x02,
+	PCF50606_OOCS_PWROKRST	= 0x04,
+	PCF50606_OOCS_BATOK	= 0x08,
+	PCF50606_OOCS_BACKOK	= 0x10,
+	PCF50606_OOCS_CHGOK	= 0x20,
+	PCF50606_OOCS_TEMPOK	= 0x40,
+	PCF50606_OOCS_WDTEXP	= 0x80,
+};
+
+enum pcf50606_reg_oocc1 {
+	PCF50606_OOCC1_GOSTDBY	= 0x01,
+	PCF50606_OOCC1_TOTRST	= 0x02,
+	PCF50606_OOCC1_CLK32ON	= 0x04,
+	PCF50606_OOCC1_WDTRST	= 0x08,
+	PCF50606_OOCC1_RTCWAK	= 0x10,
+	PCF50606_OOCC1_CHGWAK	= 0x20,
+	PCF50606_OOCC1_EXTONWAK_HIGH	= 0x40,
+	PCF50606_OOCC1_EXTONWAK_LOW	= 0x80,
+};
+
+enum pcf50606_reg_oocc2 {
+	PCF50606_OOCC2_ONKEYDB_NONE	= 0x00,
+	PCF50606_OOCC2_ONKEYDB_14ms	= 0x01,
+	PCF50606_OOCC2_ONKEYDB_62ms	= 0x02,
+	PCF50606_OOCC2_ONKEYDB_500ms	= 0x03,
+	PCF50606_OOCC2_EXTONDB_NONE	= 0x00,
+	PCF50606_OOCC2_EXTONDB_14ms	= 0x04,
+	PCF50606_OOCC2_EXTONDB_62ms	= 0x08,
+	PCF50606_OOCC2_EXTONDB_500ms	= 0x0c,
+};
+
+enum pcf50606_reg_int1 {
+	PCF50606_INT1_ONKEYR	= 0x01,	/* ONKEY rising edge */
+	PCF50606_INT1_ONKEYF	= 0x02,	/* ONKEY falling edge */
+	PCF50606_INT1_ONKEY1S	= 0x04,	/* OMKEY at least 1sec low */
+	PCF50606_INT1_EXTONR	= 0x08,	/* EXTON rising edge */
+	PCF50606_INT1_EXTONF	= 0x10,	/* EXTON falling edge */
+	PCF50606_INT1_SECOND	= 0x40,	/* RTC periodic second interrupt */
+	PCF50606_INT1_ALARM	= 0x80, /* RTC alarm time is reached */
+};
+
+enum pcf50606_reg_int2 {
+	PCF50606_INT2_CHGINS	= 0x01, /* Charger inserted */
+	PCF50606_INT2_CHGRM	= 0x02, /* Charger removed */
+	PCF50606_INT2_CHGFOK	= 0x04,	/* Fast charging OK */
+	PCF50606_INT2_CHGERR	= 0x08,	/* Error in charging mode */
+	PCF50606_INT2_CHGFRDY	= 0x10,	/* Fast charge completed */
+	PCF50606_INT2_CHGPROT	= 0x20,	/* Charging protection interrupt */
+	PCF50606_INT2_CHGWD10S	= 0x40,	/* Charger watchdig expires in 10s */
+	PCF50606_INT2_CHGWDEXP	= 0x80,	/* Charger watchdog expires */
+};
+
+enum pcf50606_reg_int3 {
+	PCF50606_INT3_ADCRDY	= 0x01,	/* ADC conversion finished */
+	PCF50606_INT3_ACDINS	= 0x02,	/* Accessory inserted */
+	PCF50606_INT3_ACDREM	= 0x04, /* Accessory removed */
+	PCF50606_INT3_TSCPRES	= 0x08,	/* Touch screen pressed */
+	PCF50606_INT3_LOWBAT	= 0x40,	/* Low battery voltage */
+	PCF50606_INT3_HIGHTMP	= 0x80, /* High temperature */
+};
+
+/* used by PSSC, PWROKM, PWROKS, */
+enum pcf50606_regu {
+	PCF50606_REGU_DCD	= 0x01,	/* DCD in phase 2 */
+	PCF50606_REGU_DCDE	= 0x02,	/* DCDE in phase 2 */
+	PCF50606_REGU_DCUD	= 0x04,	/* DCDU in phase 2 */
+	PCF50606_REGU_IO	= 0x08,	/* IO in phase 2 */
+	PCF50606_REGU_D1	= 0x10, /* D1 in phase 2 */
+	PCF50606_REGU_D2	= 0x20,	/* D2 in phase 2 */
+	PCF50606_REGU_D3	= 0x40,	/* D3 in phase 2 */
+	PCF50606_REGU_LP	= 0x80,	/* LP in phase 2 */
+};
+
+enum pcf50606_reg_dcdc4 {
+	PCF50606_DCDC4_MODE_AUTO	= 0x00,
+	PCF50606_DCDC4_MODE_PWM		= 0x01,
+	PCF50606_DCDC4_MODE_PCF		= 0x02,
+	PCF50606_DCDC4_OFF_FLOAT	= 0x00,
+	PCF50606_DCDC4_OFF_BYPASS	= 0x04,
+	PCF50606_DCDC4_OFF_PULLDOWN	= 0x08,
+	PCF50606_DCDC4_CURLIM_500mA	= 0x00,
+	PCF50606_DCDC4_CURLIM_750mA	= 0x10,
+	PCF50606_DCDC4_CURLIM_1000mA	= 0x20,
+	PCF50606_DCDC4_CURLIM_1250mA	= 0x30,
+	PCF50606_DCDC4_TOGGLE		= 0x40,
+	PCF50606_DCDC4_REGSEL_DCDC2	= 0x80,
+};
+
+enum pcf50606_reg_dcdec2 {
+	PCF50606_DCDEC2_MODE_AUTO	= 0x00,
+	PCF50606_DCDEC2_MODE_PWM	= 0x01,
+	PCF50606_DCDEC2_MODE_PCF	= 0x02,
+	PCF50606_DCDEC2_OFF_FLOAT	= 0x00,
+	PCF50606_DCDEC2_OFF_BYPASS	= 0x04,
+};
+
+enum pcf50606_reg_dcudc2 {
+	PCF50606_DCUDC2_MODE_AUTO	= 0x00,
+	PCF50606_DCUDC2_MODE_PWM	= 0x01,
+	PCF50606_DCUDC2_MODE_PCF	= 0x02,
+	PCF50606_DCUDC2_OFF_FLOAT	= 0x00,
+	PCF50606_DCUDC2_OFF_BYPASS	= 0x04,
+};
+
+enum pcf50606_reg_adcc1 {
+	PCF50606_ADCC1_TSCMODACT	= 0x01,
+	PCF50606_ADCC1_TSCMODSTB	= 0x02,
+	PCF50606_ADCC1_TRATSET		= 0x04,
+	PCF50606_ADCC1_NTCSWAPE		= 0x08,
+	PCF50606_ADCC1_NTCSWAOFF	= 0x10,
+	PCF50606_ADCC1_EXTSYNCBREAK	= 0x20,
+	/* reserved */
+	PCF50606_ADCC1_TSCINT		= 0x80,
+};
+
+enum pcf50606_reg_adcc2 {
+	PCF50606_ADCC2_ADCSTART		= 0x01,
+	/* see enum pcf50606_adcc2_adcmux */
+	PCF50606_ADCC2_SYNC_NONE	= 0x00,
+	PCF50606_ADCC2_SYNC_TXON	= 0x20,
+	PCF50606_ADCC2_SYNC_PWREN1	= 0x40,
+	PCF50606_ADCC2_SYNC_PWREN2	= 0x60,
+	PCF50606_ADCC2_RES_10BIT	= 0x00,
+	PCF50606_ADCC2_RES_8BIT		= 0x80,
+};
+
+#define PCF50606_ADCC2_ADCMUX_MASK	(0xf << 1)
+
+#define ADCMUX_SHIFT	1
+enum pcf50606_adcc2_adcmux {
+	PCF50606_ADCMUX_BATVOLT_RES	= 0x0 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_BATVOLT_SUBTR	= 0x1 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN1_RES	= 0x2 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN1_SUBTR	= 0x3 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_BATTEMP		= 0x4 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN2		= 0x5 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN3		= 0x6 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN3_RATIO	= 0x7 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_XPOS		= 0x8 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_YPOS		= 0x9 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_P1		= 0xa << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_P2		= 0xb << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_BATVOLT_ADCIN1	= 0xc << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_XY_SEQUENCE	= 0xe << ADCMUX_SHIFT,
+	PCF50606_P1_P2_RESISTANCE	= 0xf << ADCMUX_SHIFT,
+};
+
+enum pcf50606_adcs2 {
+	PCF50606_ADCS2_ADCRDY		= 0x80,
+};
+
+enum pcf50606_reg_mbcc1 {
+	PCF50606_MBCC1_CHGAPE		= 0x01,
+	PCF50606_MBCC1_AUTOFST		= 0x02,
+#define	PCF50606_MBCC1_CHGMOD_MASK	  0x1c
+#define	PCF50606_MBCC1_CHGMOD_SHIFT	  2
+	PCF50606_MBCC1_CHGMOD_QUAL	= 0x00,
+	PCF50606_MBCC1_CHGMOD_PRE	= 0x04,
+	PCF50606_MBCC1_CHGMOD_TRICKLE	= 0x08,
+	PCF50606_MBCC1_CHGMOD_FAST_CCCV	= 0x0c,
+	PCF50606_MBCC1_CHGMOD_FAST_NOCC	= 0x10,
+	PCF50606_MBCC1_CHGMOD_FAST_NOCV	= 0x14,
+	PCF50606_MBCC1_CHGMOD_FAST_SW	= 0x18,
+	PCF50606_MBCC1_CHGMOD_IDLE	= 0x1c,
+	PCF50606_MBCC1_DETMOD_LOWCHG	= 0x20,
+	PCF50606_MBCC1_DETMOD_WDRST	= 0x40,
+};
+
+enum pcf50606_reg_bvmc {
+	PCF50606_BVMC_LOWBAT		= 0x01,
+	PCF50606_BVMC_THRSHLD_NULL	= 0x00,
+	PCF50606_BVMC_THRSHLD_2V8	= 0x02,
+	PCF50606_BVMC_THRSHLD_2V9	= 0x04,
+	PCF50606_BVMC_THRSHLD_3V	= 0x08,
+	PCF50606_BVMC_THRSHLD_3V1	= 0x08,
+	PCF50606_BVMC_THRSHLD_3V2	= 0x0a,
+	PCF50606_BVMC_THRSHLD_3V3	= 0x0c,
+	PCF50606_BVMC_THRSHLD_3V4	= 0x0e,
+	PCF50606_BVMC_DISDB		= 0x10,
+};
+
+void pcf50606_reg_write(u_int8_t reg, u_int8_t val);
+
+u_int8_t pcf50606_reg_read(u_int8_t reg);
+
+u_int8_t pcf50606_reg_set_bit_mask(u_int8_t reg, u_int8_t mask, u_int8_t val);
+
+void pcf50606_init(void);
+
+#endif /* _PCF50606_H */
+
Index: u-boot/board/neo1973/neo1973.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/board/neo1973/neo1973.h	2007-02-15 00:43:54.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef _NEO1973_H
+#define _NEO1973_H
+
+enum wakeup_reason {
+	NEO1973_WAKEUP_NONE,
+	NEO1973_WAKEUP_RESET,
+	NEO1973_WAKEUP_POWER_KEY,
+	NEO1973_WAKEUP_CHARGER,
+	NEO1973_WAKEUP_ALARM,
+};
+
+extern unsigned int neo1973_wakeup_cause;
+
+void neo1973_poweroff(void);
+void neo1973_backlight(int on);
+void neo1973_vibrator(int on);
+
+#endif
Index: u-boot/board/neo1973/pcf50606.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ u-boot/board/neo1973/pcf50606.c	2007-02-15 00:43:54.000000000 +0100
@@ -0,0 +1,168 @@
+
+#include <common.h>
+#include <i2c.h>
+#include "pcf50606.h"
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+#define PCF50606_I2C_ADDR		0x08
+
+void pcf50606_reg_write(u_int8_t reg, u_int8_t val)
+{
+	i2c_write(PCF50606_I2C_ADDR, reg, 1, &val, 1);
+}
+
+u_int8_t pcf50606_reg_read(u_int8_t reg)
+{
+	u_int8_t tmp;
+	i2c_read(PCF50606_I2C_ADDR, reg, 1, &tmp, 1);
+	return tmp;
+}
+
+u_int8_t pcf50606_reg_set_bit_mask(u_int8_t reg, u_int8_t mask, u_int8_t val)
+{
+	u_int8_t tmp = pcf50606_reg_read(reg);
+	pcf50606_reg_write(reg, (val & mask) | (tmp & ~mask));
+}
+
+static const u_int8_t regs_valid[] = {
+	PCF50606_REG_OOCS, PCF50606_REG_INT1M, PCF50606_REG_INT2M,
+	PCF50606_REG_INT3M, PCF50606_REG_OOCC1, PCF50606_REG_OOCC2,
+	PCF50606_REG_PSSC, PCF50606_REG_PWROKM, PCF50606_REG_DCDC1,
+	PCF50606_REG_DCDC2, PCF50606_REG_DCDC3, PCF50606_REG_DCDC4,
+	PCF50606_REG_DCDEC1, PCF50606_REG_DCDEC2, PCF50606_REG_DCUDC1,
+	PCF50606_REG_DCUDC2, PCF50606_REG_IOREGC, PCF50606_REG_D1REGC1,
+	PCF50606_REG_D2REGC1, PCF50606_REG_D3REGC1, PCF50606_REG_LPREGC1,
+	PCF50606_REG_LPREGC2, PCF50606_REG_MBCC1, PCF50606_REG_MBCC2,
+	PCF50606_REG_MBCC3, PCF50606_REG_BBCC, PCF50606_REG_ADCC1,
+	PCF50606_REG_ADCC2, PCF50606_REG_ACDC1, PCF50606_REG_BVMC,
+	PCF50606_REG_PWMC1, PCF50606_REG_LEDC1, PCF50606_REG_LEDC2,
+	PCF50606_REG_GPOC1, PCF50606_REG_GPOC2, PCF50606_REG_GPOC3,
+	PCF50606_REG_GPOC4, PCF50606_REG_GPOC5,
+};
+
+
+static const u_int8_t initial_register_set[__NUM_PCF50606_REGS] = {
+	[PCF50606_REG_OOCS] 	= 0x00,
+	/* gap */
+	[PCF50606_REG_INT1M]	= PCF50606_INT1_SECOND,
+	[PCF50606_REG_INT2M]	= 0x00,
+	[PCF50606_REG_INT3M]	= PCF50606_INT3_TSCPRES,
+	[PCF50606_REG_OOCC1] 	= PCF50606_OOCC1_RTCWAK |
+				  PCF50606_OOCC1_CHGWAK |
+				  PCF50606_OOCC1_EXTONWAK_HIGH,
+	[PCF50606_REG_OOCC2]	= PCF50606_OOCC2_ONKEYDB_14ms |
+				  PCF50606_OOCC2_EXTONDB_14ms,
+	/* gap */
+	[PCF50606_REG_PSSC]	= 0x00,
+	[PCF50606_REG_PWROKM]	= 0x00,
+	/* gap */
+#if defined(CONFIG_ARCH_GTA01B_v2)
+	[PCF50606_REG_DCDC1]	= 0x1e,	/* GL_3V3: off */
+#elif defined(CONFIG_ARCH_GTA01B_v3)
+	[PCF50606_REG_DCDC1]	= 0x18,	/* GL_1V5: off */
+#endif
+	[PCF50606_REG_DCDC2]	= 0x00,
+	[PCF50606_REG_DCDC3]	= 0x00,
+	[PCF50606_REG_DCDC4]	= 0x30, /* 1.25A */
+
+	[PCF50606_REG_DCDEC1]	= 0xe8, /* IO_3V3: on */
+	[PCF50606_REG_DCDEC2]	= 0x00,
+
+#if defined(CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
+	[PCF50606_REG_DCUDC1]	= 0xe3, /* CORE_1V8: 1.8V */
+#elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+	[PCF50606_REG_DCUDC1]	= 0xe4, /* CORE_1V8: 2.1V */
+#endif
+	[PCF50606_REG_DCUDC2]	= 0x30, /* 1.25A current limit */
+
+#if defined(CONFIG_ARCH_GTA01_v3)
+	[PCF50606_REG_IOREGC]	= 0x13, /* VTCXO_2V8: off */
+#elif defined(CONFIG_ARCH_GTA01_v4) || defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+	//see internal bug 94 [PCF50606_REG_IOREGC]	= 0x18, /* CODEC_3V3: off */
+	[PCF50606_REG_IOREGC]	= 0xf8, /* CODEC_3V3: on */
+#endif
+
+#if defined(CONFIG_ARCH_GTA01_v3) || defined(CONFIG_ARCH_GTA01_v4)
+	[PCF50606_REG_D1REGC1]	= 0x15, /* VRF_3V: off */
+#elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+	[PCF50606_REG_D1REGC1]	= 0x16, /* BT_3V15: off */
+#endif
+
+#if defined(CONFIG_ARCH_GTA01_v3)
+	[PCF50606_REG_D2REGC1]	= 0xf8, /* SD_3V3: on */
+#elif defined(CONFIG_ARCH_GTA01_v4) || defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+	[PCF50606_REG_D2REGC1]	= 0x10, /* GL_2V5: off */
+#endif
+
+#if defined(CONFIG_ARCH_GTA01_v3)
+	[PCF50606_REG_D3REGC1]	= 0x18, /* CODEC_3V3: off */
+#elif defined(CONFIG_ARCH_GTA01_v4)
+	[PCF50606_REG_D3REGC1]	= 0x13, /* VTXCO_2V8: off */
+#elif defined(CONFIG_ARCH_GTA01B_v2) || defined(CONFIG_ARCH_GTA01B_v3)
+	[PCF50606_REG_D3REGC1]	= 0x00, /* USER1: off */
+#endif
+
+	[PCF50606_REG_LPREGC1]	= 0xf8, /* LCM_3V3: on */
+	[PCF50606_REG_LPREGC2]	= 0x00,
+
+	[PCF50606_REG_MBCC1]	= 0x01, /* CHGAPE */
+	[PCF50606_REG_MBCC2]	= 0x00,	/* unlimited charging */
+	[PCF50606_REG_MBCC3]	= 0x1a, /* 0.2*Ifast, 4.20V */
+	[PCF50606_REG_BBCC]	= 0x13, /* 50uA */
+	[PCF50606_REG_ADCC1]	= 0x00,
+	[PCF50606_REG_ADCC2]	= 0x00,
+	/* gap */
+	[PCF50606_REG_ACDC1]	= 0x00,
+	[PCF50606_REG_BVMC]	= PCF50606_BVMC_THRSHLD_2V8,
+	[PCF50606_REG_PWMC1]	= 0x00,
+	[PCF50606_REG_LEDC1]	= 0x00,
+	[PCF50606_REG_LEDC2]	= 0x00,
+	[PCF50606_REG_GPOC1]	= 0x00,
+	[PCF50606_REG_GPOC2]	= 0x00,
+	[PCF50606_REG_GPOC3]	= 0x00,
+	[PCF50606_REG_GPOC4]	= 0x00,
+	[PCF50606_REG_GPOC5]	= 0x00,
+};
+
+
+/* initialize PCF50606 register set */
+void pcf50606_init(void)
+{
+#if 0
+	/* We don't want to write to RTC, Alarm and other status registers
+	 * but rather concentrate on efficiently writing/stting those we
+	 * need */
+
+	pcf50606_reg_write(PCF50606_REG_OOCS,
+			   initial_register_set[PCF50606_REG_OOCS]);
+
+	/* GAP: 0x02-0x04 */
+
+	i2c_write(PCF50606_I2C_ADDR, 0x05, 1,
+		  &initial_register_set[0x05], 5);
+
+	/* GAP: 0x0a..0a17 */
+
+	i2c_write(PCF50606_I2C_ADDR, 0x18, 1,
+		  &initial_register_set[0x18], 2);
+
+	/* GAP: 0x1a */
+
+	i2c_write(PCF50606_I2C_ADDR, 0x1b, 1,
+		  &initial_register_set[0x1b], 17);
+
+	/* GAP: 0x2c */
+
+	i2c_write(PCF50606_I2C_ADDR, 0x2d, 1,
+		  &initial_register_set[0x2d], 3);
+
+	/* GAP: 0x30-0x32 */
+	i2c_write(PCF50606_I2C_ADDR, 0x23, 1,
+		  &initial_register_set[0x33], 10);
+#else
+	int i;
+	for (i = 0; i < ARRAY_SIZE(regs_valid); i++)
+		pcf50606_reg_write(regs_valid[i],
+				   initial_register_set[regs_valid[i]]);
+#endif
+}
Index: u-boot/common/main.c
===================================================================
--- u-boot.orig/common/main.c	2007-02-15 00:43:51.000000000 +0100
+++ u-boot/common/main.c	2007-02-15 00:43:54.000000000 +0100
@@ -61,6 +61,7 @@
 #undef DEBUG_PARSER
 
 char        console_buffer[CFG_CBSIZE];		/* console I/O buffer	*/
+int nobootdelay;
 
 #ifndef CONFIG_CMDLINE_EDITING
 static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen);
@@ -404,7 +405,7 @@
 
 	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
-	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
+	if (!nobootdelay && bootdelay >= 0 && s && !abortboot (bootdelay)) {
 # ifdef CONFIG_AUTOBOOT_KEYED
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
 # endif
