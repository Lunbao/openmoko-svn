/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>

#include "interface.h"
#include "support.h"
#include "folder.h"
#include "message.h"
#include "callbacks.h"

GtkWidget *ap_mitem_mm, *ap_mitem_fr;
GtkWidget *mitem_delete_message, *mitem_delete_folder;
				
int
main (int argc, char *argv[])
{

#ifdef ENABLE_NLS
  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
  textdomain (GETTEXT_PACKAGE);
#endif

  gtk_set_locale ();
  gtk_init (&argc, &argv);

  add_pixmap_directory (PACKAGE_DATA_DIR "/" PACKAGE "/pixmaps");

  /*
   * The following code was added by Glade to create one of each component
   * (except popup menus), just so that you see something after building
   * the project. Delete any components that you don't want shown initially.
   */
  window1 = create_window1 ();
  gtk_signal_connect (GTK_OBJECT (window1), "destroy",
		      		  GTK_SIGNAL_FUNC (gtk_exit), NULL);

  /* do some interface initializetions here */
  set_application_menu (window1);
  set_filter_menu (window1);
  load_messages (window1);
  set_action_button_menu (window1);
  
  gtk_widget_show (window1);

  gtk_main ();
  return 0;
}

void on_mitem_app_activate(GtkMenuItem *menu_item, gpointer user_data)
{
	GtkWidget *filter_menu_item = lookup_widget(GTK_WIDGET(menu_item),"filter_menu_item");
	GtkWidget *child;
	gchar *fname;
	
	g_debug("menu activate called\n");
	child = GTK_BIN(filter_menu_item)->child;
	fname = g_strdup (gtk_label_get_text(GTK_LABEL(child)));
	
	if(!custom_folder_in())
	{
		gtk_widget_set_sensitive(ap_mitem_mm,FALSE);
		gtk_widget_set_sensitive(ap_mitem_fr,FALSE);
	}
	else 
	{
		gtk_widget_set_sensitive(ap_mitem_mm,TRUE);
		if(!is_custom_folder(fname))
			gtk_widget_set_sensitive(ap_mitem_fr,FALSE);
		else
			gtk_widget_set_sensitive(ap_mitem_fr,TRUE);
	}
}

void set_application_menu (GtkWidget *widget)
{
	GtkWidget *app_message_item = lookup_widget (GTK_WIDGET(widget),"app_message_item");
	GtkWidget *app_menu = create_app_menu ();
	ap_mitem_mm = lookup_widget (GTK_WIDGET(app_menu),"ap_mitem_mm");
	ap_mitem_fr = lookup_widget(GTK_WIDGET(ap_mitem_mm),"ap_mitem_fr");
	
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(app_message_item),app_menu);
	
	g_signal_connect (G_OBJECT(app_message_item),
					  "activate",
					  G_CALLBACK(on_mitem_app_activate),
					  ap_mitem_mm);
}

void cb_filter_menu_update( GtkWidget* filter_menu, GtkWidget* filter_menu_item )
{
    gchar* text;
	gint num;
    GtkMenuItem* item = GTK_MENU_ITEM( gtk_menu_get_active(GTK_MENU(filter_menu)));
    if (GTK_BIN(item)->child)
    {
        GtkWidget *child = GTK_BIN(item)->child;
        g_assert( GTK_IS_LABEL(child) );
        gtk_label_get(GTK_LABEL (child), &text);
    }
    if (GTK_BIN(filter_menu_item)->child)
    {
        GtkWidget *child = GTK_BIN(filter_menu_item)->child;
        g_assert( GTK_IS_LABEL(child) );
        gtk_label_set(GTK_LABEL (child), text);
    }
	
	/* FIXME: later should send it to footer to display */
	num = get_folder_message_number(text);
	g_debug ("current folder contains: %d messages\n",num);
	gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(filter));
}

void set_filter_menu (GtkWidget *widget)
{
	GtkWidget *filter_menu_item = lookup_widget (GTK_WIDGET(widget),"filter_menu_item");
	GtkWidget *filter_menu = gtk_menu_new();
	
	/* load the folder names from folder_list.dat */
	FILE *fp;
	FOLDER folder;
  	char next;
	GtkWidget *fi_mitem;

	fp = fopen("folder_list.dat","r");

	fseek(fp,0,SEEK_SET);
  	while(1) 
    {
      fread(&folder,sizeof(folder),1,fp);
      if(g_strcasecmp(folder.fname,"deleted") && (next!=EOF))
		{
		  fi_mitem = gtk_menu_item_new_with_mnemonic (folder.fname);
		  gtk_menu_shell_append (GTK_MENU_SHELL (filter_menu), fi_mitem);
		  gtk_widget_show (fi_mitem);
		} 
      next = fgetc(fp);
      if(next == EOF)
		break;
      fseek(fp,-1,SEEK_CUR);
    }
  	fclose(fp);
	
	g_signal_connect (G_OBJECT(filter_menu), "selection_done", G_CALLBACK(cb_filter_menu_update), filter_menu_item );
	gtk_menu_item_set_submenu(GTK_MENU_ITEM(filter_menu_item),filter_menu);
}

GtkListStore *
create_liststore(GtkWidget *widget)
{
	GtkListStore  *store;
	GtkTreeIter    iter;
	GdkPixbuf     *icon;
	GError        *error = NULL;

  	store = gtk_list_store_new(7, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT, G_TYPE_STRING, G_TYPE_INT);

  	FILE *fp;
  	MESSAGE msg;
  	char next;

	/* add to the list*/
	fp = fopen("message.dat","r");
  
	fseek(fp,0,SEEK_SET);
  	while(1) 
    {
      fread(&msg,sizeof(msg),1,fp);

      if(msg.id != -2) /*is deleted ^_^ */
		{
	 	 	/* read the status ,set the icon */
	  	 	switch(msg.status)
			{
				case ST_UNREAD	:	icon = create_pixbuf ("Email.png");break;
				case ST_READ	:	icon = create_pixbuf ("mode_read.png");break;
				case ST_REPLIED	:	icon = create_pixbuf ("mode_reply.png");break;
				case ST_FORWARD	:	icon = create_pixbuf ("mode_forward.png");break;
			}
			
	  		if (error)
	    	{
	     		g_warning ("Could not load icon: %s\n", error->message);
	      		g_error_free(error);
	     		error = NULL;
	    	}
			gtk_list_store_append(store, &iter);
		    gtk_list_store_set(store, &iter,
						     COL_ICON, icon,
			 		         COL_FROM, msg.from,
			     			 COL_CONTENT, msg.content,
			     			 COL_TIME, msg.time,
			     			 COL_STATUS, msg.status,
							 COL_FOLDER, msg.folder,
							 COL_MSG_ID, msg.id,
							 -1);
		}
      next = fgetc(fp);
      fseek(fp,-1,SEEK_CUR);
      if(next == EOF)
		break;
    }
  fclose(fp);

  return store;
}

int in_string(char *str, char *key)
{
  int length, key_length;
  int m,n,i;

  length = strlen(str);
  key_length = strlen(key);

  n=0;

  for(m=0;m<length;m++)
    {
      if(str[m] == key[n])
	{
	  for(i=0;i<key_length;i++)
	    if(str[m+i]!= key[i+n])
	      break;

	  if(i == key_length)
	    return 1;
	  else
	    {
	      m = m+i+1;
	      n=0;
	    }
	}
    }
  return 0;
}

gboolean filter_visible_function (GtkTreeModel *model,
								  GtkTreeIter *iter,
								  gpointer data)
{
	gchar *folder;
	gchar *str_from;
	gchar *str_content;
	gchar *current_folder;
	gchar *key;
	GtkWidget *filter_menu_item;
	GtkWidget *search_entry;
	GtkWidget *toolbar;

	filter_menu_item = lookup_widget (GTK_WIDGET(data),"filter_menu_item");
	if (GTK_BIN(filter_menu_item)->child)
    {
        GtkWidget *child = GTK_BIN(filter_menu_item)->child;
        g_assert( GTK_IS_LABEL(child) );
        current_folder = g_strdup(gtk_label_get_text(GTK_LABEL(child)));
    }

	toolbar = lookup_widget (GTK_WIDGET(data),"toolbar");
	
	/* filter by folder */
	gtk_tree_model_get (model,iter,COL_FOLDER,&folder,-1);
	
	if (folder == NULL)
		return FALSE;
	else 
		if (g_strcasecmp(current_folder,"Search Result") &&
			g_strcasecmp(current_folder,folder))
		  return FALSE;
	else 
		if(gtk_notebook_get_current_page (GTK_NOTEBOOK(toolbar)) != TOOLBAR_PAGE)
		{	/* filter by search */
			search_entry = lookup_widget (GTK_WIDGET(data),"search_entry");
			key = g_strdup(gtk_entry_get_text(GTK_ENTRY(search_entry)));
      		if(strlen(key) != 0)
			{
				gtk_tree_model_get (model,iter,COL_FROM,&str_from,-1);
		  		gtk_tree_model_get (model,iter,COL_CONTENT,&str_content,-1);
		  		if(!in_string(str_from,key) && !in_string(str_content,key))
					return FALSE;
			}
		}

	return TRUE;
}

void
cell_data_func (GtkTreeViewColumn *col,
				GtkCellRenderer   *renderer,
				GtkTreeModel      *model,
				GtkTreeIter  	  *iter,
				gpointer          user_data)
{
  STATUS st;

  gtk_tree_model_get(model, iter, COL_STATUS, &st, -1);

  if (st == ST_UNREAD)
    {
      g_object_set(renderer, "weight", PANGO_WEIGHT_BOLD, "weight-set", TRUE, NULL);
    }
  else
    {
      g_object_set(renderer, "weight", PANGO_WEIGHT_BOLD, "weight-set", FALSE, NULL);
    }
}

void
onSelectionChanged (GtkTreeSelection *sel, gpointer data)
{
  GtkTreeIter  selected_row;
  GtkTreeIter  real_selected;
  GtkTreeModel *model;
  GdkPixbuf    *icon;
  gchar        *str_from, *str_content, *str_time;
  gint         msg_id;
  STATUS		status;

  g_assert(gtk_tree_selection_get_mode(sel) == GTK_SELECTION_SINGLE);

  if (gtk_tree_selection_get_selected(sel, &model, &selected_row))
    {
	  GtkWidget *detail_area;
	  GtkWidget *lbl_from;
	  GtkWidget *lbl_time;
	  GtkWidget *lbl_content;
	
      /* get seleted message params */
      gtk_tree_model_get(model,&selected_row,
						COL_FROM,&str_from,
						COL_CONTENT,&str_content,
						COL_STATUS,&status,
						COL_TIME,&str_time,
						COL_MSG_ID,&msg_id,
						-1);
      
      /* load the read mode */
      detail_area = lookup_widget (GTK_WIDGET(window1), "detail_area");
	  lbl_from = lookup_widget (GTK_WIDGET(window1), "lbl_from");
	  lbl_time = lookup_widget (GTK_WIDGET(window1), "lbl_time");
	  lbl_content = lookup_widget (GTK_WIDGET(window1), "lbl_content");
	
	  gtk_notebook_set_current_page( GTK_NOTEBOOK(detail_area), MODE_SMS_READ);
	
	  gtk_label_set_text (GTK_LABEL(lbl_from),str_from);
	  gtk_label_set_text (GTK_LABEL(lbl_time),str_time);
	  gtk_label_set_text (GTK_LABEL(lbl_content),str_content);

	  liststore = (GtkListStore *)data;
      g_assert(liststore != NULL);
	  
	  /* if it's unread change the status icon */
	  if(status == ST_UNREAD)
	  {
		/* change the icon */

      	icon = create_pixbuf("mode_read.png");

      	gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(filter),&real_selected,&selected_row);
      	gtk_list_store_set (liststore, &real_selected,
							COL_ICON, icon, 
			  				COL_STATUS, ST_READ,
			  				-1);
      
      	/* save the status in message.dat*/
      	set_msg_status (msg_id,ST_READ);
	  }
    }
  
}

void load_messages (GtkWidget *widget)
{
	GtkWidget *view = lookup_widget (GTK_WIDGET(widget), "message_treeview");
	GtkListStore *liststore;
	GtkTreeModel *model;
	GtkTreeSelection *sel;
	GtkTreeViewColumn *col;
	GtkCellRenderer   *renderer;
	
	g_assert (view != NULL);
	liststore = create_liststore(widget);
	model = GTK_TREE_MODEL(liststore);
	filter = gtk_tree_model_filter_new (model,NULL);
	gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER(filter),
											  filter_visible_function,
											  view,
											  NULL);
	gtk_tree_view_set_model(GTK_TREE_VIEW(view),GTK_TREE_MODEL(filter));
	  
	col = gtk_tree_view_column_new();
	gtk_tree_view_column_set_title(col, "From");
	  
	renderer = gtk_cell_renderer_pixbuf_new();
	gtk_tree_view_column_pack_start(col, renderer, FALSE);
	gtk_tree_view_column_set_attributes(col, renderer,
										  "pixbuf", COL_ICON,
										  NULL);
	  
	renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	gtk_tree_view_column_set_attributes(col, renderer,
						  "text", COL_FROM,
						  NULL);
	/* connect a cell data function */
	gtk_tree_view_column_set_cell_data_func(col, renderer, cell_data_func, liststore, NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);
	  
	/* 2nd column */
	col = gtk_tree_view_column_new();
	gtk_tree_view_column_set_title(col, "Subject");
	  
	renderer = gtk_cell_renderer_text_new();
	gtk_tree_view_column_pack_start(col, renderer, TRUE);
	/* connect a cell data function */
	gtk_tree_view_column_set_cell_data_func(col, renderer, cell_data_func, liststore, NULL);
	gtk_tree_view_column_set_attributes(col, renderer,
						  "text", COL_CONTENT,
						  NULL);
	gtk_tree_view_append_column(GTK_TREE_VIEW(view), col);

	sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));
	gtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);
	g_signal_connect (sel, "changed", G_CALLBACK(onSelectionChanged), liststore);
	
	gtk_widget_show (view);
	
	/* FIXME: later should send "Inbox" message number to footer*/
	g_debug ("Inbox has %d messages\n",get_folder_message_number("Inbox"));
}

void cb_menu_position_function (GtkMenu *menu,int *x,int *y,gboolean *pushin, GtkButton *button)
{
	GtkAllocation *allocation = &GTK_WIDGET(button)->allocation;
	
	gdk_window_get_origin(GTK_BUTTON(button)->event_window,x,y);
	*y += allocation->height;
	*pushin = TRUE;
	
}

void cb_action_button_clicked (GtkWidget *button, gpointer data)
{
	GtkWidget *menu = GTK_WIDGET(data);
	GtkWidget *child;
	GtkWidget *filter_menu_item = lookup_widget(button,"filter_menu_item");
	gchar *fname;
	
	if(!GTK_WIDGET_VISIBLE(menu))
	{
		gtk_menu_popup(GTK_MENU(menu),NULL,NULL,
					(GtkMenuPositionFunc) cb_menu_position_function,
					button, 0, gtk_get_current_event_time());
	}
	
	g_debug("menu activate called\n");
	child = GTK_BIN(filter_menu_item)->child;
	fname = g_strdup (gtk_label_get_text(GTK_LABEL(child)));
	
	if(!custom_folder_in())
		gtk_widget_set_sensitive(mitem_delete_folder,FALSE);
	else if (!is_custom_folder(fname))
		gtk_widget_set_sensitive(mitem_delete_folder,FALSE);
	else
		gtk_widget_set_sensitive(mitem_delete_folder,TRUE);
	
	if(message_empty())
		gtk_widget_set_sensitive(mitem_delete_message,FALSE);
}

void set_action_button_menu (GtkWidget *widget)
{
	GtkWidget *action_btn_new;
	GtkWidget *action_btn_mode;
	GtkWidget *action_btn_delete;
	GtkWidget *new_menu;
	GtkWidget *mode_menu;
	GtkWidget *delete_menu;
	
	action_btn_new = lookup_widget (GTK_WIDGET(widget),"action_btn_new");
	action_btn_mode = lookup_widget (GTK_WIDGET(widget),"action_btn_mode");
	action_btn_delete = lookup_widget (GTK_WIDGET(widget),"action_btn_delete");
	
	new_menu = create_new_menu();
	mode_menu = create_mode_menu();
	delete_menu = create_delete_menu();
	
	mitem_delete_message = lookup_widget (GTK_WIDGET(delete_menu),"mitem_delete_message");
	mitem_delete_folder = lookup_widget (GTK_WIDGET(delete_menu),"mitem_delete_folder");
	
	/* connect signal for action buttons */
	g_signal_connect (G_OBJECT(action_btn_new), "clicked", G_CALLBACK(cb_action_button_clicked),new_menu);
	g_signal_connect (G_OBJECT(action_btn_mode), "clicked", G_CALLBACK(cb_action_button_clicked),mode_menu);
	g_signal_connect (G_OBJECT(action_btn_delete), "clicked", G_CALLBACK(cb_action_button_clicked),delete_menu);
}
