This patch adds driver support for the FIC GTA01 vibrator device.  The driver
uses the existing LED class driver framework, since there's a lot of
similarity between the LED and the vibrator function.

Index: linux-2.6.22.5-moko/drivers/leds/leds-gta01.c
===================================================================
--- /dev/null
+++ linux-2.6.22.5-moko/drivers/leds/leds-gta01.c
@@ -0,0 +1,188 @@
+/*
+ * LED driver for the FIC GTA01 (Neo1973) GSM Phone Vibrator
+ *
+ * (C) 2006-2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Javi Roman <javiroman@kernel-labs.org>:
+ * 	Implement PWM support for GTA01Bv4 and later
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/arch/pwm.h>
+#include <asm/arch/gta01.h>
+
+#define COUNTER 256
+
+struct gta01_vib_priv
+{
+	struct led_classdev cdev;
+	unsigned int gpio;
+	struct mutex mutex;
+	unsigned int has_pwm;
+	struct s3c2410_pwm_t *pwm;
+};
+
+static inline struct gta01_vib_priv *pdev_to_vpriv(struct platform_device *dev)
+{
+	return platform_get_drvdata(dev);
+}
+
+static inline struct gta01_vib_priv *to_vpriv(struct led_classdev *led_cdev)
+{
+	return dev_get_drvdata(led_cdev->class_dev->dev);
+}
+
+static void gta01vib_vib_set(struct led_classdev *led_cdev,
+		enum led_brightness value)
+{
+	struct gta01_vib_priv *vp = to_vpriv(led_cdev);
+
+	/*
+ 	 * value == 255 -> 99% duty cycle (full power)
+ 	 * value == 128 -> 50% duty cycle (medium power)
+ 	 * value == 0 -> 0% duty cycle (zero power)
+ 	 */
+ 	mutex_lock(&vp->mutex);
+	if (vp->has_pwm) {
+			s3c2410_pwm_duty_cycle(value, vp->pwm);
+			s3c2410_gpio_cfgpin(vp->gpio, S3C2410_GPB3_TOUT3);
+	} else {
+		if (value)
+			s3c2410_gpio_setpin(vp->gpio, 1);
+		else
+			s3c2410_gpio_setpin(vp->gpio, 0);
+	}
+
+	mutex_unlock(&vp->mutex);
+}
+
+static struct led_classdev gta01_vib_led = {
+	.name			= "gta01:vibrator",
+	.brightness_set		= gta01vib_vib_set,
+};
+
+#ifdef CONFIG_PM
+static int gta01vib_suspend(struct platform_device *dev, pm_message_t state)
+{
+	led_classdev_suspend(&gta01_vib_led);
+	return 0;
+}
+
+static int gta01vib_resume(struct platform_device *dev)
+{
+	led_classdev_resume(&gta01_vib_led);
+	return 0;
+}
+#endif
+
+static void gta01vib_init_hw(struct platform_device *pdev)
+{
+	struct gta01_vib_priv *vp = pdev_to_vpriv(pdev);
+
+	vp->pwm->timerid= PWM3;
+	/* use same prescaler as arch/arm/plat-s3c24xx/time.c */
+	vp->pwm->prescaler = (6 - 1) / 2;
+	vp->pwm->divider = S3C2410_TCFG1_MUX3_DIV16;
+	vp->pwm->counter = COUNTER;
+	vp->pwm->comparer = COUNTER;
+
+	s3c2410_pwm_enable(vp->pwm);
+	s3c2410_pwm_start(vp->pwm);
+
+	return;
+}
+
+static int __init gta01vib_probe(struct platform_device *pdev)
+{
+	struct gta01_vib_priv *vp;
+	struct resource *r;
+
+	if (!machine_is_neo1973_gta01())
+		return -EIO;
+
+	r = platform_get_resource(pdev, 0, 0);
+	if (!r || !r->start)
+		return -EIO;
+
+	vp = kzalloc(sizeof(struct gta01_vib_priv), GFP_KERNEL);
+	if (!vp)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, vp);
+
+	vp->gpio = r->start;
+
+	/* TOUT3 */
+	if (vp->gpio == S3C2410_GPB3) {
+		vp->has_pwm = 1;
+
+		vp->pwm = s3c2410_pwm_alloc();
+		if (!vp->pwm) {
+			dev_err(&pdev->dev, "PWM allocation failed\n");
+			kfree(vp);
+			return -ENOMEM;
+		}
+
+		gta01vib_init_hw(pdev);
+	}
+
+	mutex_init(&vp->mutex);
+
+	return led_classdev_register(&pdev->dev, &gta01_vib_led);
+}
+
+static int gta01vib_remove(struct platform_device *pdev)
+{
+	struct gta01_vib_priv *vp = pdev_to_vpriv(pdev);
+
+	if (vp->has_pwm)
+		s3c2410_pwm_disable(vp->pwm);
+
+	led_classdev_unregister(&gta01_vib_led);
+	platform_set_drvdata(pdev, NULL);
+	kfree(vp);
+
+	mutex_destroy(&vp->mutex);
+
+	return 0;
+}
+
+static struct platform_driver gta01vib_driver = {
+	.probe		= gta01vib_probe,
+	.remove		= gta01vib_remove,
+#ifdef CONFIG_PM
+	.suspend	= gta01vib_suspend,
+	.resume		= gta01vib_resume,
+#endif
+	.driver		= {
+		.name		= "gta01-led",
+	},
+};
+
+static int __init gta01vib_init(void)
+{
+	return platform_driver_register(&gta01vib_driver);
+}
+
+static void __exit gta01vib_exit(void)
+{
+ 	platform_driver_unregister(&gta01vib_driver);
+}
+
+module_init(gta01vib_init);
+module_exit(gta01vib_exit);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("FIC GTA01 Vibrator driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.22.5-moko/drivers/leds/Kconfig
===================================================================
--- linux-2.6.22.5-moko.orig/drivers/leds/Kconfig
+++ linux-2.6.22.5-moko/drivers/leds/Kconfig
@@ -59,7 +59,7 @@
 
 config LEDS_S3C24XX
 	tristate "LED Support for Samsung S3C24XX GPIO LEDs"
-	depends on LEDS_CLASS && ARCH_S3C2410
+	depends on LEDS_CLASS && ARCH_S3C2410 && S3C2410_PWM
 	help
 	  This option enables support for LEDs connected to GPIO lines
 	  on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.
@@ -95,6 +95,12 @@
 	help
 	  This option enables support for the front LED on Cobalt Server
 
+config LEDS_GTA01
+	tristate "Vibrator Support for the FIC Neo1973 (GTA01) Vibrator"
+	depends on LEDS_CLASS && MACH_NEO1973_GTA01
+	help
+	  This option enables support for the Vibrator on the FIC Neo1973.
+
 comment "LED Triggers"
 
 config LEDS_TRIGGERS
Index: linux-2.6.22.5-moko/drivers/leds/Makefile
===================================================================
--- linux-2.6.22.5-moko.orig/drivers/leds/Makefile
+++ linux-2.6.22.5-moko/drivers/leds/Makefile
@@ -16,6 +16,7 @@
 obj-$(CONFIG_LEDS_WRAP)			+= leds-wrap.o
 obj-$(CONFIG_LEDS_H1940)		+= leds-h1940.o
 obj-$(CONFIG_LEDS_COBALT)		+= leds-cobalt.o
+obj-$(CONFIG_LEDS_GTA01)		+= leds-gta01.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
