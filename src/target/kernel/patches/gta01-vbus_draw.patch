Index: linux-2.6.20/arch/arm/mach-s3c2410/mach-gta01.c
===================================================================
--- linux-2.6.20.orig/arch/arm/mach-s3c2410/mach-gta01.c	2007-02-15 15:42:57.000000000 +0100
+++ linux-2.6.20/arch/arm/mach-s3c2410/mach-gta01.c	2007-02-15 16:03:56.000000000 +0100
@@ -30,6 +30,7 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/workqueue.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
@@ -40,6 +41,8 @@
 #include <linux/mtd/nand_ecc.h>
 #include <linux/mtd/partitions.h>
 
+#include <linux/pcf50606.h>
+
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>
@@ -297,8 +300,37 @@
 	}
 }
 
+/* use a work queue, since I2C API inherently schedules
+ * and we get called in hardirq context from UDC driver */
+
+struct vbus_draw {
+	struct work_struct work;
+	int ma;
+};
+static struct vbus_draw gta01_udc_vbus_drawer;
+
+static void __gta01_udc_vbus_draw(struct work_struct *work)
+{
+	if (gta01_udc_vbus_drawer.ma >= 500) {
+		/* enable fast charge */
+		printk(KERN_DEBUG "udc: enabling fast charge\n");
+		pcf50606_charge_fast(pcf50606_global, 1);
+	} else {
+		/* disable fast charge */
+		printk(KERN_DEBUG "udc: disabling fast charge\n");
+		pcf50606_charge_fast(pcf50606_global, 0);
+	}
+}
+
+static void gta01_udc_vbus_draw(unsigned int ma)
+{
+	gta01_udc_vbus_drawer.ma = ma;
+	schedule_work(&gta01_udc_vbus_drawer.work);
+}
+
 static struct s3c2410_udc_mach_info gta01_udc_cfg = {
 	.udc_command	= gta01_udc_pullup,
+	.vbus_draw	= gta01_udc_vbus_draw,
 };
 
 static struct s3c2410_ts_mach_info gta01_ts_cfg = {
@@ -464,6 +496,7 @@
 
 	s3c24xx_fb_set_platdata(&gta01_lcd_cfg);
 
+	INIT_WORK(&gta01_udc_vbus_drawer.work, __gta01_udc_vbus_draw);
 	s3c24xx_udc_set_platdata(&gta01_udc_cfg);
 	set_s3c2410ts_info(&gta01_ts_cfg);
 
