Index: linux-2.6.17.14/include/sound/soc.h
===================================================================
--- linux-2.6.17.14.orig/include/sound/soc.h
+++ linux-2.6.17.14/include/sound/soc.h
@@ -359,7 +359,7 @@ struct snd_soc_codec {
 	struct list_head dapm_paths;
 	unsigned int dapm_state;
 	unsigned int suspend_dapm_state;
-	struct delayed_work delayed_work;
+	struct work_struct delayed_work;
 
 	/* codec DAI's */
 	struct snd_soc_codec_dai *dai;
@@ -436,7 +436,7 @@ struct snd_soc_device {
 	struct snd_soc_platform *platform;
 	struct snd_soc_codec *codec;
 	struct snd_soc_codec_device *codec_dev;
-	struct delayed_work delayed_work;
+	struct work_struct delayed_work;
 	void *codec_data;
 };
 
Index: linux-2.6.17.14/sound/soc/codecs/wm8753.c
===================================================================
--- linux-2.6.17.14.orig/sound/soc/codecs/wm8753.c
+++ linux-2.6.17.14/sound/soc/codecs/wm8753.c
@@ -1422,10 +1422,9 @@ static void wm8753_set_dai_mode(struct s
 	wm8753_dai[1].codec = codec;
 }
 
-static void wm8753_work(struct work_struct *work)
+static void wm8753_work(void *data)
 {
-	struct snd_soc_codec *codec =
-		container_of(work, struct snd_soc_codec, delayed_work.work);
+	struct snd_soc_codec *codec = data;
 	wm8753_dapm_event(codec, codec->dapm_state);
 }
 
@@ -1669,7 +1668,7 @@ static int wm8753_probe(struct platform_
 	INIT_LIST_HEAD(&codec->dapm_widgets);
 	INIT_LIST_HEAD(&codec->dapm_paths);
 	wm8753_socdev = socdev;
-	INIT_DELAYED_WORK(&codec->delayed_work, wm8753_work);
+	INIT_WORK(&codec->delayed_work, wm8753_work, codec);
 
 #if defined (CONFIG_I2C) || defined (CONFIG_I2C_MODULE)
 	if (setup->i2c_address) {
Index: linux-2.6.17.14/sound/soc/soc-core.c
===================================================================
--- linux-2.6.17.14.orig/sound/soc/soc-core.c
+++ linux-2.6.17.14/sound/soc/soc-core.c
@@ -64,7 +64,7 @@ MODULE_PARM_DESC(pmdown_time, "DAPM stre
 /*
  * This function forces any delayed work to be queued and run.
  */
-static int run_delayed_work(struct delayed_work *dwork)
+static int run_delayed_work(struct work_struct *dwork)
 {
 	int ret;
 
@@ -267,10 +267,9 @@ out:
  * This is to ensure there are no pops or clicks in between any music tracks
  * due to DAPM power cycling.
  */
-static void close_delayed_work(struct work_struct *work)
+static void close_delayed_work(void *data)
 {
-	struct snd_soc_device *socdev =
-		container_of(work, struct snd_soc_device, delayed_work.work);
+	struct snd_soc_device *socdev = data;
 	struct snd_soc_codec *codec = socdev->codec;
 	struct snd_soc_codec_dai *codec_dai;
 	int i;
@@ -775,7 +774,7 @@ static int soc_probe(struct platform_dev
 	}
 
 	/* DAPM stream work */
-	INIT_DELAYED_WORK(&socdev->delayed_work, close_delayed_work);
+	INIT_WORK(&socdev->delayed_work, close_delayed_work, socdev);
 	return 0;
 
 platform_err:
Index: linux-2.6.17.14/sound/soc/s3c24xx/s3c24xx-i2s.c
===================================================================
--- linux-2.6.17.14.orig/sound/soc/s3c24xx/s3c24xx-i2s.c
+++ linux-2.6.17.14/sound/soc/s3c24xx/s3c24xx-i2s.c
@@ -60,13 +60,13 @@ static struct s3c2410_dma_client s3c24xx
 
 static struct s3c24xx_pcm_dma_params s3c24xx_i2s_pcm_stereo_out = {
 	.client		= &s3c24xx_dma_client_out,
-	.channel	= DMACH_I2S_OUT,
+	.channel	= 2,
 	.dma_addr	= S3C2410_PA_IIS + S3C2410_IISFIFO
 };
 
 static struct s3c24xx_pcm_dma_params s3c24xx_i2s_pcm_stereo_in = {
 	.client		= &s3c24xx_dma_client_in,
-	.channel	= DMACH_I2S_IN,
+	.channel	= 1,
 	.dma_addr	= S3C2410_PA_IIS + S3C2410_IISFIFO
 };
 
Index: linux-2.6.17.14/sound/soc/s3c24xx/s3c24xx-pcm.c
===================================================================
--- linux-2.6.17.14.orig/sound/soc/s3c24xx/s3c24xx-pcm.c
+++ linux-2.6.17.14/sound/soc/s3c24xx/s3c24xx-pcm.c
@@ -114,9 +114,9 @@ static void s3c24xx_pcm_enqueue(struct s
 	prtd->dma_pos = pos;
 }
 
-static void s3c24xx_audio_buffdone(struct s3c2410_dma_chan *channel,
+static void s3c24xx_audio_buffdone(s3c2410_dma_chan_t *channel,
 							void *dev_id, int size,
-							enum s3c2410_dma_buffresult result)
+							s3c2410_dma_buffresult_t result)
 {
 	struct snd_pcm_substream *substream = dev_id;
 	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
@@ -180,7 +180,8 @@ static int s3c24xx_pcm_hw_params(struct 
 						2, S3C2410_DCON_SYNC_PCLK | S3C2410_DCON_HANDSHAKE);
 	} else {
 		s3c2410_dma_config(prtd->params->channel,
-						2, S3C2410_DCON_HANDSHAKE | S3C2410_DCON_SYNC_PCLK);
+						2, S3C2410_DCON_HANDSHAKE | S3C2410_DCON_SYNC_PCLK |
+						S3C2410_DCON_CH1_I2SSDI);
 
 		s3c2410_dma_devconfig(prtd->params->channel,
 						S3C2410_DMASRC_HW, 0x3,
@@ -261,7 +262,7 @@ static int s3c24xx_pcm_trigger(struct sn
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		prtd->state |= ST_RUNNING;
 		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_START);
-		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_STARTED);
+//		s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_STARTED);
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
Index: linux-2.6.17.14/drivers/i2c/i2c-core.c
===================================================================
--- linux-2.6.17.14.orig/drivers/i2c/i2c-core.c
+++ linux-2.6.17.14/drivers/i2c/i2c-core.c
@@ -650,11 +650,11 @@ static int i2c_probe_address(struct i2c_
 	int err;
 
 	/* Make sure the address is valid */
-	if (addr < 0x03 || addr > 0x77) {
+	/*if (addr < 0x03 || addr > 0x77) {
 		dev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",
 			 addr);
 		return -EINVAL;
-	}
+	}*/
 
 	/* Skip if already in use */
 	if (i2c_check_addr(adapter, addr))
