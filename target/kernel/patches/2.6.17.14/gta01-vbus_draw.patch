Index: linux-2.6.17.14-fic4.test/arch/arm/mach-s3c2410/mach-gta01.c
===================================================================
--- linux-2.6.17.14-fic4.test.orig/arch/arm/mach-s3c2410/mach-gta01.c	2007-01-24 15:07:40.000000000 +0100
+++ linux-2.6.17.14-fic4.test/arch/arm/mach-s3c2410/mach-gta01.c	2007-01-24 15:18:50.000000000 +0100
@@ -30,6 +30,7 @@
 #include <linux/list.h>
 #include <linux/timer.h>
 #include <linux/init.h>
+#include <linux/workqueue.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
@@ -40,6 +41,8 @@
 #include <linux/mtd/nand_ecc.h>
 #include <linux/mtd/partitions.h>
 
+#include <linux/pcf50606.h>
+
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/mach/irq.h>
@@ -298,8 +301,38 @@
 	}
 }
 
+/* use a work queue, since I2C API inherently schedules
+ * and we get called in hardirq context from UDC driver */
+
+static void __gta01_udc_vbus_draw(void *v_ma);
+static int gta01_udc_vbus_draw_ma;
+static DECLARE_WORK(gta01_udc_vbus_work, __gta01_udc_vbus_draw,
+		    &gta01_udc_vbus_draw_ma);
+
+static void __gta01_udc_vbus_draw(void *v_ma)
+{
+	unsigned int ma = *((unsigned int *) v_ma);
+
+	if (ma >= 500) {
+		/* enable fast charge */
+		printk(KERN_DEBUG "udc: enabling fast charge\n");
+		pcf50606_charge_fast(pcf50606_global, 1);
+	} else {
+		/* disable fast charge */
+		printk(KERN_DEBUG "udc: disabling fast charge\n");
+		pcf50606_charge_fast(pcf50606_global, 0);
+	}
+}
+
+static void gta01_udc_vbus_draw(unsigned int ma)
+{
+	gta01_udc_vbus_draw_ma = ma;
+	schedule_work(&gta01_udc_vbus_work);
+}
+
 static struct s3c2410_udc_mach_info gta01_udc_cfg = {
 	.udc_command	= gta01_udc_pullup,
+	.vbus_draw	= gta01_udc_vbus_draw,
 };
 
 static struct s3c2410_ts_mach_info gta01_ts_cfg = {
