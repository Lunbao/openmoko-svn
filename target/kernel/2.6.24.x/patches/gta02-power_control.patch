Index: linux-2.6.24/arch/arm/plat-s3c24xx/neo1973_pm_bt.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-s3c24xx/neo1973_pm_bt.c
+++ linux-2.6.24/arch/arm/plat-s3c24xx/neo1973_pm_bt.c
@@ -19,7 +19,9 @@
 #include <linux/pcf50606.h>
 
 #include <asm/hardware.h>
+#include <asm/mach-types.h>
 #include <asm/arch/gta01.h>
+#include <asm/arch/gta02.h>
 
 #define DRVMSG "FIC Neo1973 Bluetooth Power Management"
 
@@ -27,14 +29,30 @@
 		       char *buf)
 {
 	if (!strcmp(attr->attr.name, "power_on")) {
-		if (pcf50606_onoff_get(pcf50606_global,
-					PCF50606_REGULATOR_D1REG) &&
-		    pcf50606_voltage_get(pcf50606_global,
-					 PCF50606_REGULATOR_D1REG) == 3100)
-			goto out_1;
+		switch (machine_arch_type) {
+		case MACH_TYPE_NEO1973_GTA01:
+			if (pcf50606_onoff_get(pcf50606_global,
+						PCF50606_REGULATOR_D1REG) &&
+			    pcf50606_voltage_get(pcf50606_global,
+						 PCF50606_REGULATOR_D1REG) == 3100)
+				goto out_1;
+			break;
+		case MACH_TYPE_NEO1973_GTA02:
+			if (s3c2410_gpio_getpin(GTA02_GPIO_BT_EN))
+				goto out_1;
+			break;
+		}
 	} else if (!strcmp(attr->attr.name, "reset")) {
-		if (s3c2410_gpio_getpin(GTA01_GPIO_BT_EN) == 0)
-			goto out_1;
+		switch (machine_arch_type) {
+		case MACH_TYPE_NEO1973_GTA01:
+			if (s3c2410_gpio_getpin(GTA01_GPIO_BT_EN) == 0)
+				goto out_1;
+			break;
+		case MACH_TYPE_NEO1973_GTA02:
+			if (s3c2410_gpio_getpin(GTA02_GPIO_BT_EN) == 0)
+				goto out_1;
+			break;
+		}
 	}
 
 	return strlcpy(buf, "0\n", 3);
@@ -48,20 +66,37 @@
 	unsigned long on = simple_strtoul(buf, NULL, 10);
 
 	if (!strcmp(attr->attr.name, "power_on")) {
-		/* if we are powering up, assert reset, then power, then
-		 * release reset */
-		if (on) {
-			s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, 0);
-			pcf50606_voltage_set(pcf50606_global,
-					     PCF50606_REGULATOR_D1REG,
-					     3100);
+		switch (machine_arch_type) {
+		case MACH_TYPE_NEO1973_GTA01:
+			/* if we are powering up, assert reset, then power,
+			 * then release reset */
+			if (on) {
+				s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, 0);
+				pcf50606_voltage_set(pcf50606_global,
+						     PCF50606_REGULATOR_D1REG,
+						     3100);
+			}
+			pcf50606_onoff_set(pcf50606_global,
+					   PCF50606_REGULATOR_D1REG, on);
+			s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, on);
+			break;
+		case MACH_TYPE_NEO1973_GTA02:
+			if (on)
+				s3c2410_gpio_setpin(GTA02_GPIO_BT_EN, 0);
+			else
+				s3c2410_gpio_setpin(GTA02_GPIO_BT_EN, 1);
+			break;
 		}
-		pcf50606_onoff_set(pcf50606_global,
-				   PCF50606_REGULATOR_D1REG, on);
-		s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, on);
 	} else if (!strcmp(attr->attr.name, "reset")) {
 		/* reset is low-active, so we need to invert */
-		s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, on ? 0 : 1);
+		switch (machine_arch_type) {
+		case MACH_TYPE_NEO1973_GTA01:
+			s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, on ? 0 : 1);
+			break;
+		case MACH_TYPE_NEO1973_GTA02:
+			s3c2410_gpio_setpin(GTA02_GPIO_BT_EN, on ? 0 : 1);
+			break;
+		}
 	}
 
 	return count;
@@ -107,9 +142,16 @@
 {
 	dev_info(&pdev->dev, DRVMSG ": starting\n");
 
-	/* we make sure that the voltage is off */
-	pcf50606_onoff_set(pcf50606_global,
-			   PCF50606_REGULATOR_D1REG, 0);
+	switch (machine_arch_type) {
+	case MACH_TYPE_NEO1973_GTA01:
+		/* we make sure that the voltage is off */
+		pcf50606_onoff_set(pcf50606_global,
+				   PCF50606_REGULATOR_D1REG, 0);
+		break;
+	case MACH_TYPE_NEO1973_GTA02:
+		/* FIXME: implementation */
+		break;
+	}
 	/* we pull reset to low to make sure that the chip doesn't
 	 * drain power through the reset line */
 	s3c2410_gpio_setpin(GTA01_GPIO_BT_EN, 0);
Index: linux-2.6.24/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c
===================================================================
--- linux-2.6.24.orig/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c
+++ linux-2.6.24/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c
@@ -19,8 +19,15 @@
 #include <linux/errno.h>
 
 #include <asm/hardware.h>
+#include <asm/mach-types.h>
 #include <asm/arch/gta01.h>
 
+#ifdef CONFIG_MACH_NEO1973_GTA02
+#include <asm/arch/gta02.h>
+#include <linux/pcf50633.h>
+#include <asm/arch/regs-gpioj.h>
+#endif
+
 struct gta01pm_priv {
 	int gpio_ngsm_en;
 	struct console *con;
@@ -54,8 +61,16 @@
 		if (s3c2410_gpio_getpin(GTA01_GPIO_MODEM_RST))
 			goto out_1;
 	} else if (!strcmp(attr->attr.name, "download")) {
-		if (s3c2410_gpio_getpin(GTA01_GPIO_MODEM_DNLOAD))
-			goto out_1;
+#ifdef CONFIG_MACH_NEO1973_GTA01
+		if (machine_is_neo1973_gta01())
+			if (s3c2410_gpio_getpin(GTA01_GPIO_MODEM_DNLOAD))
+				goto out_1;
+#endif
+#ifdef CONFIG_MACH_NEO1973_GTA02
+		if (machine_is_neo1973_gta02())
+			if (s3c2410_gpio_getpin(GTA02_GPIO_nDL_GSM))
+				goto out_1;
+#endif
 	}
 
 	return strlcpy(buf, "0\n", 3);
@@ -70,32 +85,65 @@
 
 	if (!strcmp(attr->attr.name, "power_on")) {
 		if (on) {
-			dev_info(dev, "powering up GSM, thus disconnecting "
-				 "serial console\n");
+			if (gta01_gsm.con) {
+				dev_info(dev, "powering up GSM, thus "
+					 "disconnecting serial console\n");
 
-			if (gta01_gsm.con)
 				console_stop(gta01_gsm.con);
+			}
 
 			if (gta01_gsm.gpio_ngsm_en)
 				s3c2410_gpio_setpin(gta01_gsm.gpio_ngsm_en, 0);
 
+			switch (system_rev) {
+#ifdef CONFIG_MACH_NEO1973_GTA02
+			case GTA02v2_SYSTEM_REV:
+			case GTA02v3_SYSTEM_REV:
+			case GTA02v4_SYSTEM_REV:
+			case GTA02v5_SYSTEM_REV:
+				pcf50633_gpio_set(pcf50633_global,
+						  PCF50633_GPIO2, 1);
+				break;
+#endif
+			}
+
 			s3c2410_gpio_setpin(GTA01_GPIO_MODEM_ON, 1);
 		} else {
 			s3c2410_gpio_setpin(GTA01_GPIO_MODEM_ON, 0);
 
+			switch (system_rev) {
+#ifdef CONFIG_MACH_NEO1973_GTA02
+			case GTA02v2_SYSTEM_REV:
+			case GTA02v3_SYSTEM_REV:
+			case GTA02v4_SYSTEM_REV:
+			case GTA02v5_SYSTEM_REV:
+				pcf50633_gpio_set(pcf50633_global,
+						  PCF50633_GPIO2, 0);
+				break;
+#endif
+			}
+
 			if (gta01_gsm.gpio_ngsm_en)
 				s3c2410_gpio_setpin(gta01_gsm.gpio_ngsm_en, 1);
 
-			if (gta01_gsm.con)
+			if (gta01_gsm.con) {
 				console_start(gta01_gsm.con);
 
-			dev_info(dev, "powered down GSM, thus enabling "
-				 "serial console\n");
+				dev_info(dev, "powered down GSM, thus enabling "
+					 "serial console\n");
+			}
 		}
 	} else if (!strcmp(attr->attr.name, "reset")) {
 		s3c2410_gpio_setpin(GTA01_GPIO_MODEM_RST, on);
 	} else if (!strcmp(attr->attr.name, "download")) {
-		s3c2410_gpio_setpin(GTA01_GPIO_MODEM_DNLOAD, on);
+#ifdef CONFIG_MACH_NEO1973_GTA01
+		if (machine_is_neo1973_gta01())
+			s3c2410_gpio_setpin(GTA01_GPIO_MODEM_DNLOAD, on);
+#endif
+#ifdef CONFIG_MACH_NEO1973_GTA02
+		if (machine_is_neo1973_gta02())
+			s3c2410_gpio_setpin(GTA02_GPIO_nDL_GSM, on);
+#endif
 	}
 
 	return count;
@@ -134,7 +182,7 @@
 static struct attribute *gta01_gsm_sysfs_entries[] = {
 	&dev_attr_power_on.attr,
 	&dev_attr_reset.attr,
-	NULL,
+	&dev_attr_download.attr,
 	NULL
 };
 
@@ -158,8 +206,17 @@
 		gta01_gsm.gpio_ngsm_en = GTA01Bv2_GPIO_nGSM_EN;
 		s3c2410_gpio_setpin(GTA01v3_GPIO_nGSM_EN, 0);
 		break;
+#ifdef CONFIG_MACH_NEO1973_GTA02
+	case GTA02v1_SYSTEM_REV:
+	case GTA02v2_SYSTEM_REV:
+	case GTA02v3_SYSTEM_REV:
+	case GTA02v4_SYSTEM_REV:
+	case GTA02v5_SYSTEM_REV:
+		gta01_gsm.gpio_ngsm_en = 0;
+		break;
+#endif
 	default:
-		dev_warn(&pdev->dev, "Unknown GTA01 Revision 0x%x, "
+		dev_warn(&pdev->dev, "Unknown Neo1973 Revision 0x%x, "
 			 "some PM features not available!!!\n",
 			 system_rev);
 		break;
@@ -175,9 +232,13 @@
 		break;
 	}
 
-	gta01_gsm.con = find_s3c24xx_console();
-	if (!gta01_gsm.con)
-		dev_warn(&pdev->dev, "cannot find S3C24xx console driver\n");
+	if (machine_is_neo1973_gta01()) {
+		gta01_gsm.con = find_s3c24xx_console();
+		if (!gta01_gsm.con)
+			dev_warn(&pdev->dev,
+				 "cannot find S3C24xx console driver\n");
+	} else
+		gta01_gsm.con = NULL;
 
 	return sysfs_create_group(&pdev->dev.kobj, &gta01_gsm_attr_group);
 }
