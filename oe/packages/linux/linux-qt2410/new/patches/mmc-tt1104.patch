Index: linux-2.6.17.7-new/arch/arm/mach-s3c2410/dma.c
===================================================================
--- linux-2.6.17.7-new.orig/arch/arm/mach-s3c2410/dma.c	2006-08-07 17:35:41.000000000 +0200
+++ linux-2.6.17.7-new/arch/arm/mach-s3c2410/dma.c	2006-08-07 17:38:53.000000000 +0200
@@ -947,7 +947,12 @@
 		return -EINVAL;
 	}
 
-	dcon |= S3C2410_DCON_HWTRIG;
+	if (chan->hwsrc >= 0) {
+		dcon |= S3C2410_DCON_HWTRIG;
+		dcon |= ((chan->hwsrc << S3C2410_DCON_SRCSHIFT) 
+						&& S3C2410_DCON_SRCMASK);
+	}
+
 	dcon |= S3C2410_DCON_INTREQ;
 
 	pr_debug("%s: dcon now %08x\n", __FUNCTION__, dcon);
@@ -1027,7 +1032,8 @@
 int s3c2410_dma_devconfig(int channel,
 			  s3c2410_dmasrc_t source,
 			  int hwcfg,
-			  unsigned long devaddr)
+			  unsigned long devaddr,
+			  unsigned int hwsrc)
 {
 	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
 
@@ -1038,6 +1044,7 @@
 
 	chan->source = source;
 	chan->dev_addr = devaddr;
+	chan->hwsrc = hwsrc;
 
 	switch (source) {
 	case S3C2410_DMASRC_HW:
Index: linux-2.6.17.7-new/drivers/mmc/mmc.c
===================================================================
--- linux-2.6.17.7-new.orig/drivers/mmc/mmc.c	2006-08-07 17:35:41.000000000 +0200
+++ linux-2.6.17.7-new/drivers/mmc/mmc.c	2006-08-07 17:38:53.000000000 +0200
@@ -817,7 +817,7 @@
 
 		cmd.opcode = MMC_ALL_SEND_CID;
 		cmd.arg = 0;
-		cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
+		cmd.flags = (MMC_RSP_R2 | MMC_CMD_BCR) & ~MMC_RSP_CRC;
 
 		err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
 		if (err == MMC_ERR_TIMEOUT) {
@@ -1105,8 +1105,10 @@
 
 	mmc_read_csds(host);
 
+#if 0
 	if (host->mode == MMC_MODE_SD)
 		mmc_read_scrs(host);
+#endif
 }
 
 
Index: linux-2.6.17.7-new/drivers/mmc/s3c2410mci.c
===================================================================
--- linux-2.6.17.7-new.orig/drivers/mmc/s3c2410mci.c	2006-08-07 17:38:52.000000000 +0200
+++ linux-2.6.17.7-new/drivers/mmc/s3c2410mci.c	2006-08-07 18:12:38.000000000 +0200
@@ -1,56 +1,298 @@
 /*
- *  linux/drivers/mmc/s3c2410mci.h - Samsung S3C2410 SDI Interface driver
+ *  linux/drivers/mmc/s3c2410mci.c - Samsung S3C2410 SDI Interface driver
  *
- *  Copyright (C) 2004 Thomas Kleffel, All Rights Reserved.
+ *  Copyright (C) 2004-2005 Thomas Kleffel, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * 2006-08-02 Harald Welte <hwelte@hmw-consulting.de>
+ * 	- Merge with 2.6.17.x
+ * 	- CodingStyle cleanup
  */
 #include <linux/config.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/err.h>
 #include <linux/dma-mapping.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/protocol.h>
+#include <linux/platform_device.h>
 #include <linux/clk.h>
 
 #include <asm/dma.h>
 #include <asm/dma-mapping.h>
-#include <asm/arch/dma.h>
 
 #include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/mach/mmc.h>
 
 #include <asm/arch/regs-sdi.h>
 #include <asm/arch/regs-gpio.h>
-#include <asm/arch/mmc.h>
-
-#ifdef CONFIG_MMC_DEBUG
-#define DBG(x...)       printk(KERN_INFO x)
-#else
-#define DBG(x...)       do { } while (0)
-#endif
 
 #include "s3c2410mci.h"
 
-#define DRIVER_NAME "mmci-s3c2410"
-#define PFX DRIVER_NAME ": "
+#define DRIVER_NAME	"mmci-s3c24xx"
+#define PFX		DRIVER_NAME ": "
+
+#define NULLDBG(x...)	do { } while (0)
+#define KERNDBG(x...)	printk(KERN_DEBUG PFX x)
+#define KERNINF(x...)	printk(KERN_INFO PFX x)
+#define KERNERR(x...)	printk(KERN_ERR PFX x)
+
+#define ERR(x...)	KERNERR("ERROR: " x)
+#define DBG(x...)	KERNDBG(x)
+#define INFO(x...)	KERNINF(x)
+#define INTDBG(x...)	NULLDBG("INTERRUPT: " x)
+#define SGDBG(x...)	NULLDBG("SG: " x)
+#define DMADBG(x...)	KERNERR("DMA: " x)
+#define PIODBG(x...)	NULLDBG("PIO: " x)
+#define FAILDBG(x...)	KERNINF("FAILED REQUEST: " x)
+#define CONFDBG(x...)	KERNDBG("CONFIG: " x)
 
 #define RESSIZE(ressource) (((ressource)->end - (ressource)->start)+1)
 
+/* FIXME: move this to mmc.h */
+#define MMC_RSP_MASK	0x1f
+
+typedef enum {
+	DMAP_READ,
+	DMAP_WRITE,
+} eDMAPurpose_t;
+
 static struct s3c2410_dma_client s3c2410sdi_dma_client = {
 	.name		= "s3c2410-sdi",
 };
 
+static void finalize_request(struct s3c2410sdi_host *host);
+static void s3c2410sdi_send_request(struct mmc_host *mmc);
+static void s3c2410sdi_reset(struct s3c2410sdi_host *host);
+
+static inline void 
+debug_dump_registers(struct s3c2410sdi_host *host, char *prefix)
+{
+	u32 con, pre, cmdarg, cmdcon, cmdsta, r0, r1, r2, r3, timer, bsize;
+	u32 datcon, datcnt, datsta, fsta, imask;
+		
+	con 	= readl(host->base + S3C2410_SDICON);
+	pre 	= readl(host->base + S3C2410_SDIPRE);
+	cmdarg 	= readl(host->base + S3C2410_SDICMDARG);
+	cmdcon 	= readl(host->base + S3C2410_SDICMDCON);
+	cmdsta 	= readl(host->base + S3C2410_SDICMDSTAT);
+	r0 	= readl(host->base + S3C2410_SDIRSP0);
+	r1 	= readl(host->base + S3C2410_SDIRSP1);
+	r2 	= readl(host->base + S3C2410_SDIRSP2);
+	r3 	= readl(host->base + S3C2410_SDIRSP3);
+	timer 	= readl(host->base + S3C2410_SDITIMER);
+	bsize 	= readl(host->base + S3C2410_SDIBSIZE);
+	datcon 	= readl(host->base + S3C2410_SDIDCON);
+	datcnt 	= readl(host->base + S3C2410_SDIDCNT);
+	datsta 	= readl(host->base + S3C2410_SDIDSTA);
+	fsta 	= readl(host->base + S3C2410_SDIFSTA);
+	
+	if (host->is2440)
+		imask = readl(host->base + S3C2440_SDIIMSK);
+	else
+		imask = readl(host->base + S3C2440_SDIIMSK);
+	
+	DBG("%s  CON:[%08x]  PRE:[%08x]  TMR:[%08x]\n", prefix, con, pre,
+	    timer);
+	DBG("%s CCON:[%08x] CARG:[%08x] CSTA:[%08x]\n", prefix, cmdcon,
+	    cmdarg, cmdsta);
+	DBG("%s DCON:[%08x] FSTA:[%08x] DSTA:[%08x] DCNT:[%08x]\n", prefix, 
+	    datcon, fsta, datsta, datcnt);
+	DBG("%s   R0:[%08x]   R1:[%08x]   R2:[%08x]   R3:[%08x]\n", prefix,
+	    r0, r1, r2, r3);
+}
+
+static inline char *cmd2str(int cmd)
+{
+	switch (cmd) {
+		case  0: return "GO_IDLE_STATE";
+		case  1: return "ALL_SEND_OCR";
+		case  2: return "ALL_SEND_CID";
+		case  3: return "ALL_SEND_RELATIVE_ADD";
+		case  6: return "ACMD: SD_SET_BUSWIDTH";
+		case  7: return "SEL_DESEL_CARD";
+		case  9: return "SEND_CSD";
+		case 10: return "SEND_CID";
+		case 11: return "READ_UNTIL_STOP";
+		case 12: return "STOP_TRANSMISSION";
+		case 13: return "SEND_STATUS";
+		case 15: return "GO_INACTIVE_STATE";
+		case 16: return "SET_BLOCKLEN";
+		case 17: return "READ_SINGLE_BLOCK";
+		case 18: return "READ_MULTIPLE_BLOCK";
+		case 24: return "WRITE_SINGLE_BLOCK";
+		case 25: return "WRITE_MULTIPLE_BLOCK";
+		case 41: return "ACMD: SD_APP_OP_COND";
+		case 55: return "APP_CMD";
+		default: return "UNKNOWN";
+	}
+}
+
+static inline char *err2str(int err) {
+	switch (err) {
+		case 0: return "OK";
+		case 1: return "TIMEOUT";
+		case 2: return "BADCRC";
+		case 3: return "FIFO";
+		case 4: return "FAILED";
+		case 5: return "INVALID";
+		case 6: return "BUSY";
+		case 7: return "DMA";
+		case 8: return "CANCELED";
+		default: return "UNKNOWN";
+	}
+}
+
+static inline void 
+prepare_dbgmsg(struct s3c2410sdi_host *host, struct mmc_command *cmd, int stop) 
+{
+ 	snprintf(host->dbgmsg_cmd, 300, 
+		"#[%u]%s op:[%s(%i)] arg:[0x%08x] flags:[%x] retries:[%u]", 
+		host->ccnt, (stop?" STOP":""), cmd2str(cmd->opcode), 
+		cmd->opcode, cmd->arg, cmd->flags, cmd->retries);
+		
+	if (cmd->data)
+		snprintf(host->dbgmsg_dat, 300, 
+			"#[%u] bsize:%u blocks:%u bytes:%u", 
+			host->dcnt, (1 << cmd->data->blksz_bits) , cmd->data->blocks, 
+			cmd->data->blocks * (1 << cmd->data->blksz_bits));
+	else	
+		host->dbgmsg_dat[0] = '\0';
+}
+
+
+static inline int 
+get_data_buffer(struct s3c2410sdi_host *host, u32 *words, u32 **pointer)
+{
+	struct scatterlist *sg;
+
+	if (!host->pio_active)
+		return -EINVAL;
+	if (!host->mrq)
+		return -EINVAL;
+	if (!host->mrq->data)
+		return -EINVAL;
+
+	if (host->pio_sgptr >= host->mrq->data->sg_len) {
+		SGDBG("get_data_buffer(): no more buffers (%i/%i)\n", 
+		      host->pio_sgptr, host->mrq->data->sg_len);
+		return -EBUSY;
+	}
+	sg = &host->mrq->data->sg[host->pio_sgptr];
+
+	*words	= sg->length >> 2;
+	*pointer= page_address(sg->page) + sg->offset;
+
+	host->pio_sgptr++;
+	
+	SGDBG("get_data_buffer(): new buffer (%i/%i)\n", 
+	      host->pio_sgptr, host->mrq->data->sg_len);
+		
+	return 0;
+}
+
+#define FIFO_FILL(host) ((readl(host->base + S3C2410_SDIFSTA) & S3C2410_SDIFSTA_COUNTMASK) >> 2)
+#define FIFO_FREE(host) ((63 - (readl(host->base + S3C2410_SDIFSTA) & S3C2410_SDIFSTA_COUNTMASK)) >> 2)
+
+static inline void do_pio_read(struct s3c2410sdi_host *host)
+{
+	int res;
+	u32 fifo;
+	void __iomem *from_ptr;
+
+	//FIX2410: write real prescaler to host, it might be set slow to fix 2410
+	writel(host->prescaler, host->base + S3C2410_SDIPRE);
+	//writel(0xff, host->base + S3C2410_SDIPRE);
+
+	from_ptr = host->base + ((host->is2440)?S3C2440_SDIDATA:S3C2410_SDIDATA);
+
+	while ((fifo = FIFO_FILL(host))) {
+		if(!host->pio_words) {
+			res = get_data_buffer(host, &host->pio_words, &host->pio_ptr);
+			if (res) {
+				PIODBG("pio_read(): complete (no more buffers).\n");
+				host->pio_active = 0;
+				host->dma_complete = 1;
+				finalize_request(host);
+				return;
+				/* handle no data condition */
+			}
+				
+			PIODBG("pio_read(): new target: [%i]@[%p]\n", 
+			       host->pio_words, host->pio_ptr);
+		}
+		
+		PIODBG("pio_read(): fifo:[%i] buffer:[%i] dcnt:[%08X]\n", 
+		       fifo, host->pio_words, readl(host->base + S3C2410_SDIDCNT));
+
+		if (fifo > host->pio_words)
+			fifo = host->pio_words;
+
+		host->pio_words-= fifo;
+
+		while (fifo--)
+			*(host->pio_ptr++) = readl(from_ptr);
+	}
+	
+	if (!host->pio_words) {
+		res = get_data_buffer(host, &host->pio_words, &host->pio_ptr);
+		if (res) {
+			PIODBG("pio_read(): complete (no more buffers).\n");
+			host->pio_active = 0;
+			host->dma_complete = 1;
+			finalize_request(host);
+		}
+	}	
+}
+
+static inline void do_pio_write(struct s3c2410sdi_host *host)
+{
+	int res;
+	u32 fifo;
+
+	void __iomem *to_ptr;
+
+	to_ptr = host->base + ((host->is2440)?S3C2440_SDIDATA:S3C2410_SDIDATA);
+
+	while ((fifo = FIFO_FREE(host))) {
+		if (!host->pio_words) {
+			res = get_data_buffer(host, &host->pio_words,
+					      &host->pio_ptr);
+			if (res) {
+				PIODBG("pio_write(): complete\n");
+				host->pio_active = 0;
+				host->dma_complete = 1;
+				finalize_request(host);				
+				return;
+			}	
+			
+			PIODBG("pio_write(): new source: [%i]@[%p]\n", 
+			       host->pio_words, host->pio_ptr);
+			
+		}
+
+		if (fifo > host->pio_words)
+			fifo = host->pio_words;
+
+		host->pio_words-= fifo;
+
+		while (fifo--)
+			writel(*(host->pio_ptr++), to_ptr);
+	}	
+}
+
+static inline u32 enable_imask(struct s3c2410sdi_host *host, u32 imask)
+{
+	u32 newmask;
+
+	newmask = readl(host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
+	newmask|= imask;
+
+	writel(newmask, host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
+
+	return newmask;
+}
+
 /*
  * ISR for SDI Interface IRQ
  * Communication between driver and ISR works as follows:
@@ -72,490 +314,757 @@
  * 7) ISR completes host->complete_request
  * 8) ISR disables interrupts
  * 9) Driver wakes up and takes care of the request
-*/
+ *
+ * Note: "->error"-fields are expected to be set to 0 before the request
+ *       was issued by mmc.c - therefore they are only set, when an error
+ *       contition comes up
+ */
 
 static irqreturn_t s3c2410sdi_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct s3c2410sdi_host *host;
-	u32 sdi_csta, sdi_dsta, sdi_dcnt;
+	struct mmc_command *cmd;
+	u32 sdi_csta, sdi_dsta, sdi_fsta, sdi_dcnt, sdi_imsk;
 	u32 sdi_cclear, sdi_dclear;
 	unsigned long iflags;
+	char *reason = "unknown";
 
 	host = (struct s3c2410sdi_host *)dev_id;
 
-	/* Check for things not supposed to happen */
-	if(!host) return IRQ_HANDLED;
+	if (!host)
+		return IRQ_NONE;
 	
+	spin_lock_irqsave( &host->complete_lock, iflags);
+
 	sdi_csta 	= readl(host->base + S3C2410_SDICMDSTAT);
 	sdi_dsta 	= readl(host->base + S3C2410_SDIDSTA);
 	sdi_dcnt 	= readl(host->base + S3C2410_SDIDCNT);
-	
-	DBG(PFX "IRQ csta=0x%08x dsta=0x%08x dcnt:0x%08x\n", sdi_csta, sdi_dsta, sdi_dcnt);
-		
-	spin_lock_irqsave( &host->complete_lock, iflags);
-	
-	if( host->complete_what==COMPLETION_NONE ) {
+	sdi_fsta 	= readl(host->base + S3C2410_SDIFSTA);
+	sdi_imsk	= readl(host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
+	sdi_cclear	= 0;
+	sdi_dclear	= 0;
+
+	if (host->complete_what == COMPLETION_NONE ) {
+		reason = "nothing to complete";
 		goto clear_imask;
 	}
-	
-	if(!host->mrq) { 
+
+	if (!host->mrq) {
+		reason = "no active mrq";
 		goto clear_imask;
 	}
 
+	cmd = host->cmd_is_stop?host->mrq->stop:host->mrq->cmd;
 	
-	sdi_csta 	= readl(host->base + S3C2410_SDICMDSTAT);
+	if (!cmd) {
+		reason = "no active cmd";
+		goto clear_imask;
+	}
+
+	if (!host->dodma) {
+		if ((host->pio_active == XFER_WRITE) &&
+		    (sdi_fsta & S3C2410_SDIFSTA_TFDET))
+			do_pio_write(host);
+		if ((host->pio_active == XFER_READ) && 
+		    (sdi_fsta & S3C2410_SDIFSTA_RFDET))
+			do_pio_read(host);
+	}
 	sdi_dsta 	= readl(host->base + S3C2410_SDIDSTA);
-	sdi_dcnt 	= readl(host->base + S3C2410_SDIDCNT);
-	sdi_cclear	= 0;
-	sdi_dclear	= 0;
-	
-	
-	if(sdi_csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {
-		host->mrq->cmd->error = MMC_ERR_TIMEOUT;
-		goto transfer_closed;
+	sdi_fsta 	= readl(host->base + S3C2410_SDIFSTA);
+		
+	if (sdi_csta & S3C2410_SDICMDSTAT_CMDTIMEOUT) {
+		cmd->error = MMC_ERR_TIMEOUT;
+		reason = "error: command timeout";
+		goto close_transfer;
 	}
 
-	if(sdi_csta & S3C2410_SDICMDSTAT_CMDSENT) {
-		if(host->complete_what == COMPLETION_CMDSENT) {
-			host->mrq->cmd->error = MMC_ERR_NONE;
-			goto transfer_closed;
-		}
+	if (sdi_csta & S3C2410_SDICMDSTAT_CMDSENT) {
+		if (host->complete_what == COMPLETION_CMDSENT) {
+			reason = "ok: command sent";
+			goto close_transfer;
+		}	
 
 		sdi_cclear |= S3C2410_SDICMDSTAT_CMDSENT;
 	}
 
-	if(sdi_csta & S3C2410_SDICMDSTAT_CRCFAIL) {
-		if (host->mrq->cmd->flags & MMC_RSP_136) {
-			DBG(PFX "s3c2410 fixup : ignore CRC fail with long rsp\n");
-		}
-		else {
-			DBG(PFX "COMMAND CRC FAILED %x\n", sdi_csta);
-			if(host->mrq->cmd->flags & MMC_RSP_CRC) {
-				host->mrq->cmd->error = MMC_ERR_BADCRC;
-				goto transfer_closed;
-			}
+	if (sdi_csta & S3C2410_SDICMDSTAT_CRCFAIL) {
+	#if 0
+		if (cmd->flags & MMC_RSP_CRC) {
+			cmd->error = MMC_ERR_BADCRC;
+			reason = "error: bad command crc";
+			goto close_transfer;
 		}
+	#endif
+
 		sdi_cclear |= S3C2410_SDICMDSTAT_CRCFAIL;
 	}
 
-	if(sdi_csta & S3C2410_SDICMDSTAT_RSPFIN) {
-		if(host->complete_what == COMPLETION_RSPFIN) {
-			host->mrq->cmd->error = MMC_ERR_NONE;
-			goto transfer_closed;
+	if (sdi_csta & S3C2410_SDICMDSTAT_RSPFIN) {
+		if (host->complete_what == COMPLETION_RSPFIN) {
+			reason = "ok: command response received";
+			goto close_transfer;
 		}
 
-		if(host->complete_what == COMPLETION_XFERFINISH_RSPFIN) {
-			host->mrq->cmd->error = MMC_ERR_NONE;
+		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)
 			host->complete_what = COMPLETION_XFERFINISH;
-		}
-
+				
 		sdi_cclear |= S3C2410_SDICMDSTAT_RSPFIN;
 	}
 
-	if(sdi_dsta & S3C2410_SDIDSTA_FIFOFAIL) {
-		host->mrq->cmd->error = MMC_ERR_NONE;
+	/* errors handled after this point are only relevant
+	   when a data transfer is in progress */
+	if (!cmd->data)
+		goto clear_status_bits;
+
+	/* Check for FIFO failure on 2410 */
+	if ((!host->is2440) && (sdi_dsta & S3C2410_SDIDSTA_FIFOFAIL)) {
+		cmd->data->error = MMC_ERR_FIFO;
+		reason = "error: 2410 fifo failure";
+		goto close_transfer;
+	}
+
+	/* Check for FIFO failure on 2440 */
+	if ((host->is2440) && (sdi_fsta & S3C2440_SDIFSTA_FIFOFAIL)) {
 		host->mrq->data->error = MMC_ERR_FIFO;
-		goto transfer_closed;
+		reason = "error: 2440 fifo failure";
+		goto close_transfer;
 	}
 
-	if(sdi_dsta & S3C2410_SDIDSTA_RXCRCFAIL) {
-		host->mrq->cmd->error = MMC_ERR_NONE;
-		host->mrq->data->error = MMC_ERR_BADCRC;
-		goto transfer_closed;
+	if (sdi_dsta & S3C2410_SDIDSTA_RXCRCFAIL) {
+		cmd->data->error = MMC_ERR_BADCRC;
+		reason = "error: bad data crc (outgoing)";
+		goto close_transfer;
 	}
 
-	if(sdi_dsta & S3C2410_SDIDSTA_CRCFAIL) {
-		DBG(PFX "DATA CRC FAILED %u\n", sdi_csta);
-		host->mrq->cmd->error = MMC_ERR_NONE;
-		host->mrq->data->error = MMC_ERR_BADCRC;
-		goto transfer_closed;
+	if (sdi_dsta & S3C2410_SDIDSTA_CRCFAIL) {
+		cmd->data->error = MMC_ERR_BADCRC;
+		reason = "error: bad data crc (incoming)";
+		goto close_transfer;
 	}
 
-	if(sdi_dsta & S3C2410_SDIDSTA_DATATIMEOUT) {
-		host->mrq->cmd->error = MMC_ERR_NONE;
-		host->mrq->data->error = MMC_ERR_TIMEOUT;
-		goto transfer_closed;
+	if (sdi_dsta & S3C2410_SDIDSTA_DATATIMEOUT) {
+		cmd->data->error = MMC_ERR_TIMEOUT;
+		reason = "error: data timeout";
+		goto close_transfer;
 	}
 
-	if(sdi_dsta & S3C2410_SDIDSTA_XFERFINISH) {
-		if(host->complete_what == COMPLETION_XFERFINISH) {
-			host->mrq->cmd->error = MMC_ERR_NONE;
-			host->mrq->data->error = MMC_ERR_NONE;
-			goto transfer_closed;
+	if (sdi_dsta & S3C2410_SDIDSTA_XFERFINISH) {
+		if (host->complete_what == COMPLETION_XFERFINISH) {
+			reason = "ok: data transfer completed";
+			goto close_transfer;
 		}
 
-		if(host->complete_what == COMPLETION_XFERFINISH_RSPFIN) {
-			host->mrq->data->error = MMC_ERR_NONE;
+		if (host->complete_what == COMPLETION_XFERFINISH_RSPFIN)
 			host->complete_what = COMPLETION_RSPFIN;
-		}
 
 		sdi_dclear |= S3C2410_SDIDSTA_XFERFINISH;
 	}
-
+	
+clear_status_bits:
 	writel(sdi_cclear, host->base + S3C2410_SDICMDSTAT);
 	writel(sdi_dclear, host->base + S3C2410_SDIDSTA);
 
-	spin_unlock_irqrestore( &host->complete_lock, iflags);
-	DBG(PFX "IRQ still waiting.\n");
-	return IRQ_HANDLED;
+	goto irq_out;
 
-
-transfer_closed:
-	writel(sdi_cclear, host->base + S3C2410_SDICMDSTAT);
-	writel(sdi_dclear, host->base + S3C2410_SDIDSTA);
+close_transfer:
 	host->complete_what = COMPLETION_NONE;
-	complete(&host->complete_request);
-	writel(0, host->base + S3C2410_SDIIMSK);
-	if (host->mrq->data && host->mrq->data->error != MMC_ERR_NONE)
-		complete(&host->complete_dma);
-	spin_unlock_irqrestore( &host->complete_lock, iflags);
-	DBG(PFX "IRQ transfer closed.\n");
-	return IRQ_HANDLED;
-	
+	host->pio_active = XFER_NONE;
+
+	writel(0, host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
+	disable_irq_nosync(host->irq);	
+
+	finalize_request(host);	
+
+	goto irq_out;
+
 clear_imask:
-	writel(0, host->base + S3C2410_SDIIMSK);
+	writel(0, host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
+	disable_irq_nosync(host->irq);	
+
+irq_out:
+	INTDBG("csta=0x%08x dsta=0x%08x fsta=0x%08x dcnt:0x%08x status:%s.\n",
+		sdi_csta, sdi_dsta, sdi_fsta, sdi_dcnt, reason);
+
 	spin_unlock_irqrestore( &host->complete_lock, iflags);
-	DBG(PFX "IRQ clear imask.\n");
 	return IRQ_HANDLED;
 
 }
 
-
-/*
- * ISR for the CardDetect Pin
-*/
+/* ISR for the CardDetect Pin */
 
 static irqreturn_t s3c2410sdi_irq_cd(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct s3c2410sdi_host *host = (struct s3c2410sdi_host *)dev_id;
-	mmc_detect_change(host->mmc, S3C2410SDI_CDLATENCY);
-
+	mmc_detect_change(host->mmc, 0);
+	
 	return IRQ_HANDLED;
 }
 
-
-
-static void s3c2410sdi_dma_done_callback(s3c2410_dma_chan_t *dma_ch, void *buf_id,
-	int size, s3c2410_dma_buffresult_t result)
+void s3c2410sdi_dma_done_callback(s3c2410_dma_chan_t *dma_ch, void *buf_id,
+				  int size, s3c2410_dma_buffresult_t result)
 {	unsigned long iflags;
-	u32 sdi_csta, sdi_dsta,sdi_dcnt;
+	u32 sdi_csta, sdi_dsta, sdi_fsta, sdi_dcnt;
 	struct s3c2410sdi_host *host = (struct s3c2410sdi_host *)buf_id;
-	
-	sdi_csta 	= readl(host->base + S3C2410_SDICMDSTAT);
-	sdi_dsta 	= readl(host->base + S3C2410_SDIDSTA);
-	sdi_dcnt 	= readl(host->base + S3C2410_SDIDCNT);
-	
-	DBG(PFX "DMAD csta=0x%08x dsta=0x%08x dcnt:0x%08x result:0x%08x\n", sdi_csta, sdi_dsta, sdi_dcnt, result);
-	
-	spin_lock_irqsave( &host->complete_lock, iflags);
-	
-	if(!host->mrq) goto out;
-	if(!host->mrq->data) goto out;
-	
-	
+
 	sdi_csta 	= readl(host->base + S3C2410_SDICMDSTAT);
 	sdi_dsta 	= readl(host->base + S3C2410_SDIDSTA);
+	sdi_fsta 	= readl(host->base + S3C2410_SDIFSTA);
 	sdi_dcnt 	= readl(host->base + S3C2410_SDIDCNT);
-		
-	if( result!=S3C2410_RES_OK ) {
+
+	if (!host->mrq)
+		return;
+	if (!host->mrq->data)
+		return;
+	if (!host->dmatogo)
+		return;
+
+	spin_lock_irqsave(&host->complete_lock, iflags);
+
+	if (result != S3C2410_RES_OK) {
+		FAILDBG("DMA FAILED: csta=0x%08x dsta=0x%08x fsta=0x%08x "
+			"dcnt:0x%08x result:0x%08x togo:%u\n", 
+			sdi_csta, sdi_dsta, sdi_fsta, sdi_dcnt, result,
+			host->dmatogo);
 		goto fail_request;
 	}
 	
-	
-	if(host->mrq->data->flags & MMC_DATA_READ) {
-		if( sdi_dcnt>0 ) {
-			goto fail_request;
-		}
-	}
-	
-out:	
-	complete(&host->complete_dma);
+	host->dmatogo--;
+	if (host->dmatogo) {
+		DMADBG("DMA DONE %i (%i) togo DSTA:[%08x] DCNT:[%08x]\n",
+			host->dmatogo, size, sdi_dsta, sdi_dcnt);
+		goto out;
+	}	
+		
+	host->dma_complete = 1;
+	DMADBG("DMA FINISHED (%i)  DSTA:[%08x] DCNT:[%08x]\n", size, 
+		sdi_dsta, sdi_dcnt);
+	finalize_request(host);
+
+out:
 	spin_unlock_irqrestore( &host->complete_lock, iflags);
 	return;
 
 
 fail_request:
-	host->mrq->data->error = MMC_ERR_FAILED;
+	host->mrq->data->error = MMC_ERR_DMA;
 	host->complete_what = COMPLETION_NONE;
-	complete(&host->complete_request);
-	writel(0, host->base + S3C2410_SDIIMSK);
+	host->dma_complete = 1;
+	writel(0, host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
+	finalize_request(host);	
 	goto out;
 
 }
 
+#define DBGCMD(x, args...) 	do { 					\
+					if (fail) {			\
+						FAILDBG(x, ## args);	\
+						debug_dump_registers(host, ""); \
+					} else 				\
+						DBG(x, ## args);	\
+				} while (0)
 
-static void s3c2410sdi_dma_setup(struct s3c2410sdi_host *host, s3c2410_dmasrc_t source) {
-	
-	s3c2410_dma_devconfig(host->dma, source, 3, host->mem->start + S3C2410_SDIDATA);
-	s3c2410_dma_config(host->dma, 4, (1<<23) | (2<<24));
-	s3c2410_dma_set_buffdone_fn(host->dma, s3c2410sdi_dma_done_callback);
-	s3c2410_dma_setflags(host->dma, S3C2410_DMAF_AUTOSTART);
-}
 
-static void s3c2410sdi_request(struct mmc_host *mmc, struct mmc_request *mrq) {
- 	struct s3c2410sdi_host *host = mmc_priv(mmc);
-	struct device *dev = mmc_dev(host->mmc);
-	struct platform_device *pdev = to_platform_device(dev);
-	u32 sdi_carg, sdi_ccon, sdi_timer;
-	u32 sdi_bsize, sdi_dcon, sdi_imsk;
-	int dma_len = 0;
+static void debug_command(struct s3c2410sdi_host *host,
+			  struct mmc_command *cmd, int fail)
+{
+	if (!cmd)
+		return;
 
-	DBG(PFX "request: [CMD] opcode:0x%02x arg:0x%08x flags:%x retries:%u\n",
-	    mrq->cmd->opcode, mrq->cmd->arg, mrq->cmd->flags, mrq->cmd->retries);
-	DBG(PFX "request : %s mode\n",mmc->mode == MMC_MODE_MMC ? "mmc" : "sd");
+	if (cmd->error == MMC_ERR_NONE)
+		DBGCMD("CMD[OK] %s R0:[0x%08x]\n", host->dbgmsg_cmd,
+			cmd->resp[0]);
+	else
+		DBGCMD("CMD[%s] %s\n", err2str(cmd->error),
+			host->dbgmsg_cmd);
 
+	if (!cmd->data)
+		return;
+
+	if (cmd->data->error == MMC_ERR_NONE)
+		DBGCMD("DAT[%s] %s\n", err2str(cmd->data->error),
+			host->dbgmsg_dat);
+	else
+		DBGCMD("DAT[%s] %s DCNT:[0x%08x]\n", 
+			err2str(cmd->data->error), host->dbgmsg_dat,
+			readl(host->base + S3C2410_SDIDCNT));
+}
 
-	sdi_ccon = mrq->cmd->opcode & S3C2410_SDICMDCON_INDEX;
-	sdi_ccon|= S3C2410_SDICMDCON_SENDERHOST;
-	sdi_ccon|= S3C2410_SDICMDCON_CMDSTART;
+static void finalize_request(struct s3c2410sdi_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd = host->cmd_is_stop?mrq->stop:mrq->cmd;	
+	int debug_as_failure = 0;
+	
+	if (host->complete_what != COMPLETION_NONE)
+		return;
+	
+	if (cmd->data && (cmd->error == MMC_ERR_NONE) &&
+	    (cmd->data->error == MMC_ERR_NONE)) {
+		if (!host->dma_complete) {
+			DBG("DMA Missing!\n");
+			//s3c2410_dma_debug_channel(host->dma);
+			return;
+		}
+	}
 
-	sdi_carg = mrq->cmd->arg;
+	/* Read response */
+	cmd->resp[0] = readl(host->base + S3C2410_SDIRSP0);
+	cmd->resp[1] = readl(host->base + S3C2410_SDIRSP1);
+	cmd->resp[2] = readl(host->base + S3C2410_SDIRSP2);
+	cmd->resp[3] = readl(host->base + S3C2410_SDIRSP3);
+
+	/* FIX2410: reset clock speed, as it could still be set low for 2410 */
+	writel(host->prescaler, host->base + S3C2410_SDIPRE);
+	//writel(0xff, host->base + S3C2410_SDIPRE);
+	
+	if (cmd->error)
+		debug_as_failure = 1;
+	if (cmd->data && cmd->data->error)
+		debug_as_failure = 1;
+	//if(cmd->flags & MMC_RSP_MAYFAIL) debug_as_failure = 0;
 
-	sdi_timer= 0xFFFF;
+	debug_command(host, cmd, debug_as_failure);
 
-	sdi_bsize= 0;
-	sdi_dcon = 0;
-	sdi_imsk = 0;
+	/* Cleanup controller */
+	writel(0, host->base + S3C2410_SDICMDARG);
+	writel(0, host->base + S3C2410_SDIDCON);
+	writel(0, host->base + S3C2410_SDICMDCON);
+	writel(0, host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK));
 
-	/* enable interrupts for transmission errors */
-	sdi_imsk |= S3C2410_SDIIMSK_RESPONSEND;
-	sdi_imsk |= S3C2410_SDIIMSK_CRCSTATUS;
+	if (cmd->data && cmd->error)
+		cmd->data->error = cmd->error;
 
-	host->complete_what = COMPLETION_CMDSENT;
+	if (cmd->data && cmd->data->stop && (!host->cmd_is_stop)) {
+		host->cmd_is_stop = 1;
+		s3c2410sdi_send_request(host->mmc);
+		return;
+	}
+	
+	/* If we have no data transfer we are finished here */
+	if (!mrq->data)
+		goto request_done;
+	
+	/* Calulate the amout of bytes transfer, but only if no error */
+	if (mrq->data->error == MMC_ERR_NONE)
+		mrq->data->bytes_xfered = 
+				(mrq->data->blocks << mrq->data->blksz_bits);
+	else
+		mrq->data->bytes_xfered = 0;
 
-	if (mrq->cmd->flags & MMC_RSP_PRESENT) {
-		host->complete_what = COMPLETION_RSPFIN;
+	/* If we had an error while transfering data we flush the
+	 * DMA channel and the fifo to clear out any garbage */
+	if (mrq->data->error != MMC_ERR_NONE) {
+		if (host->dodma)
+			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
+		
+		if (host->is2440) {
+			/* Clear failure register and reset fifo */
+			writel(S3C2440_SDIFSTA_FIFORESET |
+					S3C2440_SDIFSTA_FIFOFAIL,
+			host->base + S3C2410_SDIFSTA);
+		} else {
+			u32 sdi_con;
 
-		sdi_ccon |= S3C2410_SDICMDCON_WAITRSP;
-		sdi_imsk |= S3C2410_SDIIMSK_CMDTIMEOUT;
+			/* reset fifo */
+			sdi_con = readl(host->base + S3C2410_SDICON);
+			sdi_con|= S3C2410_SDICON_FIFORESET;
 
-	} else {
-		/* We need the CMDSENT-Interrupt only if we want are not waiting
-		 * for a response
-		 */
-		sdi_imsk |= S3C2410_SDIIMSK_CMDSENT;
+			writel(sdi_con, host->base + S3C2410_SDICON);
+		}
 	}
 
-	if(mrq->cmd->flags & MMC_RSP_136) {
-		sdi_ccon|= S3C2410_SDICMDCON_LONGRSP;
+request_done:			
+	host->mrq = NULL;
+	mmc_request_done(host->mmc, mrq);
+}
+
+
+void s3c2410sdi_dma_setup(struct s3c2410sdi_host *host, eDMAPurpose_t purpose)
+{
+	static int setup_ok = 0;
+	static eDMAPurpose_t lp = -1;
+	s3c2410_dmasrc_t source;
+
+	if (lp == purpose)
+		return;
+
+	lp = purpose;
+	
+	switch (purpose) {
+		case DMAP_READ:
+			source  = S3C2410_DMASRC_HW;
+			break;
+
+		case DMAP_WRITE:
+			source  = S3C2410_DMASRC_MEM;
+			break;
+		
+		default:
+			return;
 	}
 
-	if(mrq->cmd->flags & MMC_RSP_CRC) {
-			sdi_imsk |= S3C2410_SDIIMSK_RESPONSECRC;
+	s3c2410_dma_devconfig(host->dma, source, 3, host->mem->start + 
+				((host->is2440)?S3C2440_SDIDATA:S3C2410_SDIDATA), 2);
+	if (!setup_ok) {
+		s3c2410_dma_config(host->dma, 4, (1<<23));
+		s3c2410_dma_set_buffdone_fn(host->dma, 
+					s3c2410sdi_dma_done_callback);
+		s3c2410_dma_setflags(host->dma, S3C2410_DMAF_AUTOSTART);
+		setup_ok = 1;
 	}
+}
 
+static void s3c2440sdi_send_command(struct s3c2410sdi_host *host,
+				    struct mmc_command *cmd)
+{
+	u32 ccon, imsk;
 
-	if (mrq->data) {
-		host->complete_what = COMPLETION_XFERFINISH_RSPFIN;
+	imsk  = S3C2410_SDIIMSK_CRCSTATUS | S3C2410_SDIIMSK_CMDTIMEOUT |
+		S3C2410_SDIIMSK_RESPONSEND | S3C2410_SDIIMSK_CMDSENT |
+		S3C2410_SDIIMSK_RESPONSECRC;
 
-		sdi_bsize = (1 << mrq->data->blksz_bits);
-		host->size = mrq->data->blocks << mrq->data->blksz_bits;
+	enable_imask(host, imsk);
 
-		sdi_dcon  = (mrq->data->blocks & S3C2410_SDIDCON_BLKNUM_MASK);
-		sdi_dcon |= S3C2410_SDIDCON_DMAEN;
+	if (cmd->data) 
+		host->complete_what = COMPLETION_XFERFINISH_RSPFIN;
+	else if (cmd->flags & MMC_RSP_MASK) 
+		host->complete_what = COMPLETION_RSPFIN;
+	else
+		host->complete_what = COMPLETION_CMDSENT;
 
-		sdi_imsk |= S3C2410_SDIIMSK_FIFOFAIL;
-		sdi_imsk |= S3C2410_SDIIMSK_DATACRC;
-		sdi_imsk |= S3C2410_SDIIMSK_DATATIMEOUT;
-		sdi_imsk |= S3C2410_SDIIMSK_DATAFINISH;
-		sdi_imsk |= 0xFFFFFFE0;
+	writel(cmd->arg, host->base + S3C2410_SDICMDARG);
 
-		DBG(PFX "request: [DAT] bsize:%u blocks:%u bytes:%u\n",
-			sdi_bsize, mrq->data->blocks, mrq->data->blocks * sdi_bsize);
+	ccon = cmd->opcode & S3C2410_SDICMDCON_INDEX;
+	ccon|= S3C2410_SDICMDCON_SENDERHOST | S3C2410_SDICMDCON_CMDSTART;
 
-		if (host->bus_width == MMC_BUS_WIDTH_4) {
-			sdi_dcon |= S3C2410_SDIDCON_WIDEBUS;
-		}
+	if (cmd->flags & MMC_RSP_MASK)
+		ccon |= S3C2410_SDICMDCON_WAITRSP;
+
+	if (cmd->flags & MMC_RSP_136)
+		ccon|= S3C2410_SDICMDCON_LONGRSP;
+	/*	
+	DBG("Sending Command: CCON:[%08X] DCON:[%08X] BSIZE:[%08X] IMASK:[%08X] DCNT:[%08X]\n",
+	       ccon, readl(host->base + S3C2410_SDIDCON), readl(host->base + S3C2410_SDIBSIZE),
+	       readl(host->base + ((host->is2440)?S3C2440_SDIIMSK:S3C2410_SDIIMSK)),
+	       readl(host->base + S3C2410_SDIDCNT));
+	*/
+	writel(ccon, host->base + S3C2410_SDICMDCON);
+}
 
-		if(!(mrq->data->flags & MMC_DATA_STREAM)) {
-			sdi_dcon |= S3C2410_SDIDCON_BLOCKMODE;
-		}
+static int s3c2440sdi_setup_data(struct s3c2410sdi_host *host, 
+				 struct mmc_data *data)
+{
+	u32 dcon, imsk, stoptries=3;
 
-		if(mrq->data->flags & MMC_DATA_WRITE) {
-			sdi_dcon |= S3C2410_SDIDCON_TXAFTERRESP;
-			sdi_dcon |= S3C2410_SDIDCON_XFER_TXSTART;
+	/* write DCON register */
+	
+	if (!data) {
+		writel(0, host->base + S3C2410_SDIDCON);
+		return 0;
+	}
+	
+	while (readl(host->base + S3C2410_SDIDSTA) & 
+		     (S3C2410_SDIDSTA_TXDATAON | S3C2410_SDIDSTA_RXDATAON)) {
+		ERR("sdi_setup_data() transfer in progress. Trying to stop...\n");
+		
+		writel(0, host->base + S3C2410_SDIDCON);
+		s3c2410sdi_reset(host);
+		
+		if(0 == (stoptries--)) {
+			debug_dump_registers(host, "Data recovery:");
+					
+			/* TODO: get Controller out of data transfer mode */
+			return -EINVAL;
 		}
+	}	
+	
+	dcon  = data->blocks & S3C2410_SDIDCON_BLKNUM_MASK;
+	
+	if (host->dodma)
+		dcon |= S3C2410_SDIDCON_DMAEN;
 
-		if(mrq->data->flags & MMC_DATA_READ) {
-			sdi_dcon |= S3C2410_SDIDCON_RXAFTERCMD;
-			sdi_dcon |= S3C2410_SDIDCON_XFER_RXSTART;
-		}
+	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)
+		dcon |= S3C2410_SDIDCON_WIDEBUS;
 
-		s3c2410sdi_dma_setup(host, mrq->data->flags & MMC_DATA_WRITE ? S3C2410_DMASRC_MEM : S3C2410_DMASRC_HW);
+	if (!(data->flags & MMC_DATA_STREAM))
+		dcon |= S3C2410_SDIDCON_BLOCKMODE;
+	
+	if (data->flags & MMC_DATA_WRITE) {
+		dcon |= S3C2410_SDIDCON_TXAFTERRESP;
+		dcon |= S3C2410_SDIDCON_XFER_TXSTART;
+	}
 
-		/* see DMA-API.txt */
-		dma_len = dma_map_sg(&pdev->dev, mrq->data->sg, \
-				mrq->data->sg_len, \
-				mrq->data->flags & MMC_DATA_READ ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
-
-		/* start DMA */
-		s3c2410_dma_enqueue(host->dma, (void *) host,
-			sg_dma_address(&mrq->data->sg[0]),
-			(mrq->data->blocks << mrq->data->blksz_bits) );
+	if (data->flags & MMC_DATA_READ) {
+		dcon |= S3C2410_SDIDCON_RXAFTERCMD;
+		dcon |= S3C2410_SDIDCON_XFER_RXSTART;	
 	}
 
-	host->mrq = mrq;
+	if (host->is2440) {
+		dcon |= S3C2440_SDIDCON_DS_WORD;
+		dcon |= S3C2440_SDIDCON_DATSTART;
+	}
 
-	init_completion(&host->complete_request);
-	init_completion(&host->complete_dma);
+	writel(dcon, host->base + S3C2410_SDIDCON);
 
-	/* Clear command and data status registers */
-	writel(0xFFFFFFFF, host->base + S3C2410_SDICMDSTAT);
-	writel(0xFFFFFFFF, host->base + S3C2410_SDIDSTA);
+	writel((1 << data->blksz_bits), host->base + S3C2410_SDIBSIZE);
+
+	imsk =	S3C2410_SDIIMSK_FIFOFAIL | S3C2410_SDIIMSK_DATACRC |
+		S3C2410_SDIIMSK_DATATIMEOUT | S3C2410_SDIIMSK_DATAFINISH;
+
+	enable_imask(host, imsk);
 
-	/* Setup SDI controller */
-	writel(sdi_bsize,host->base + S3C2410_SDIBSIZE);
-	writel(sdi_timer,host->base + S3C2410_SDITIMER);
-	writel(sdi_imsk,host->base + S3C2410_SDIIMSK);
-
-	/* Setup SDI command argument and data control */
-	writel(sdi_carg, host->base + S3C2410_SDICMDARG);
-	writel(sdi_dcon, host->base + S3C2410_SDIDCON);
-
-	/* This initiates transfer */
-	writel(sdi_ccon, host->base + S3C2410_SDICMDCON);
-
-	/* Wait for transfer to complete */
-	wait_for_completion(&host->complete_request);
-	DBG(PFX "[CMD] request complete.\n");
-	if(mrq->data) {
-		wait_for_completion(&host->complete_dma);
-		DBG(PFX "[DAT] DMA complete.\n");
+	if (host->is2440) 
+		writel(0x007FFFFF, host->base + S3C2410_SDITIMER);
+	else {
+		writel(0x0000FFFF, host->base + S3C2410_SDITIMER);
+	
+		/*FIX2410: set slow clock to prevent timeouts on read*/
+		if (data->flags & MMC_DATA_READ)
+			writel(255, host->base + S3C2410_SDIPRE);
 	}
+		
+	//debug_dump_registers(host, "Data setup:");
 	
-	/* Cleanup controller */
-	writel(0, host->base + S3C2410_SDICMDARG);
-	writel(0, host->base + S3C2410_SDIDCON);
-	writel(0, host->base + S3C2410_SDICMDCON);
-	writel(0, host->base + S3C2410_SDIIMSK);
+	return 0;
+}
 
-	/*  Read response */
-	mrq->cmd->resp[0] = readl(host->base + S3C2410_SDIRSP0);
-	mrq->cmd->resp[1] = readl(host->base + S3C2410_SDIRSP1);
-	mrq->cmd->resp[2] = readl(host->base + S3C2410_SDIRSP2);
-	mrq->cmd->resp[3] = readl(host->base + S3C2410_SDIRSP3);
+static int s3c2440sdi_prepare_pio(struct s3c2410sdi_host *host,
+				  struct mmc_data *data)
+{
+	int rw = (data->flags & MMC_DATA_WRITE)?1:0;
+	if(rw != ((data->flags & MMC_DATA_READ)?0:1)) return -EINVAL;
 
-	host->mrq = NULL;
+	host->pio_sgptr = 0;
+	host->pio_words = 0;
+	host->pio_active = rw?XFER_WRITE:XFER_READ;
+	
+	if(rw) enable_imask(host, S3C2410_SDIIMSK_TXFIFOHALF);
+	else   enable_imask(host, S3C2410_SDIIMSK_RXFIFOHALF | S3C2410_SDIIMSK_RXFIFOFULL);
 
-	DBG(PFX "request done.\n");
+	return 0;
+}
 
-	/* If we have no data transfer we are finished here */
-	if (!mrq->data) goto request_done;
+static int s3c2440sdi_prepare_dma(struct s3c2410sdi_host *host, 
+				  struct mmc_data *data)
+{
+	int dma_len, i;
+	int rw = (data->flags & MMC_DATA_WRITE)?1:0;
 
-	dma_unmap_sg(&pdev->dev, mrq->data->sg, dma_len, \
-			mrq->data->flags & MMC_DATA_READ ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+	if (rw != ((data->flags & MMC_DATA_READ)?0:1))
+		return -EINVAL;
 
-	/* Calulate the amout of bytes transfer, but only if there was
-	 * no error
-	 */
-	if(mrq->data->error == MMC_ERR_NONE) {
-		mrq->data->bytes_xfered = (mrq->data->blocks << mrq->data->blksz_bits);
-	} else {
-		mrq->data->bytes_xfered = 0;
-	}
+	s3c2410sdi_dma_setup(host, rw?DMAP_WRITE:DMAP_READ);
+	s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
+				
+	dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+				(rw)?DMA_TO_DEVICE:DMA_FROM_DEVICE);
+					
 
-	/* If we had an error while transfering data we flush the
-	 * DMA channel to clear out any garbage
-	 */
-	if(mrq->data->error != MMC_ERR_NONE) {
-		s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
-		DBG(PFX "flushing DMA.\n");		
-	}
+	if (dma_len == 0)
+		return -ENOMEM;
+
+	host->dma_complete = 0;
+	host->dmatogo = dma_len;	
+		
+	for (i = 0; i < dma_len; i++) {
+		int res;
+		DBG("dma_enqueue %i:[%u]@[%u]\n", i, 
+		    sg_dma_address(&data->sg[i]), sg_dma_len(&data->sg[i]));
+		res = s3c2410_dma_enqueue(host->dma, (void *) host, 
+					  sg_dma_address(&data->sg[i]),
+					  sg_dma_len(&data->sg[i]));
+		
+		if (res) {
+			s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_FLUSH);
+			return -EBUSY;
+		}
+ 	}
+	
+	//s3c2410_dma_ctrl(host->dma, S3C2410_DMAOP_START);
+
+	return 0;
+}
 
-	if(mrq->data->stop) mmc_wait_for_cmd(mmc, mrq->data->stop, 3);
+static void s3c2410sdi_send_request(struct mmc_host *mmc)
+{
+	struct s3c2410sdi_host *host = mmc_priv(mmc);
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd = host->cmd_is_stop?mrq->stop:mrq->cmd;
+	
+	/* Increment request counters */
+	host->ccnt++;
+
+	if (cmd->data)
+		host->dcnt++;
+	
+	prepare_dbgmsg(host, cmd, host->cmd_is_stop);
+			
+	/* Clear command, data and fifo status registers
+	 * Fifo clear only necessary on 2440, but doesn't hurt on 2410 */
+	writel(0xFFFFFFFF, host->base + S3C2410_SDICMDSTAT);
+	writel(0xFFFFFFFF, host->base + S3C2410_SDIDSTA);
+	writel(0xFFFFFFFF, host->base + S3C2410_SDIFSTA);
 
-request_done:
+	if (cmd->data) {
+		int res;
+		res = s3c2440sdi_setup_data(host, cmd->data);
+
+		if(res) {
+			cmd->error = MMC_ERR_DMA;
+			cmd->data->error = MMC_ERR_DMA;
+
+			mmc_request_done(mmc, mrq);
+			return;
+		} 
 
-	mrq->done(mrq);
+	
+		if (host->dodma)
+			res = s3c2440sdi_prepare_dma(host, cmd->data);
+		else
+			res = s3c2440sdi_prepare_pio(host, cmd->data);
+
+		if (res) {
+			cmd->error = MMC_ERR_DMA;
+			cmd->data->error = MMC_ERR_DMA;
+
+			mmc_request_done(mmc, mrq);
+			return;
+		} 
+
+	}
+	
+	s3c2440sdi_send_command(host, cmd);	
+	enable_irq(host->irq);
 }
 
-static void s3c2410sdi_set_ios(struct mmc_host *mmc, struct mmc_ios *ios) {
+static void s3c2410sdi_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+ 	struct s3c2410sdi_host *host = mmc_priv(mmc);
+		
+	host->cmd_is_stop = 0;
+	host->mrq = mrq;
+	
+	s3c2410sdi_send_request(mmc);
+}
+
+static void s3c2410sdi_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
 	struct s3c2410sdi_host *host = mmc_priv(mmc);
 	u32 sdi_psc, sdi_con;
-
+	
 	/* Set power */
 	sdi_con = readl(host->base + S3C2410_SDICON);
-	switch(ios->power_mode) {
-		case MMC_POWER_ON:
-		case MMC_POWER_UP:
-			DBG(PFX "power on\n");
-			s3c2410_gpio_cfgpin(S3C2410_GPE5, S3C2410_GPE5_SDCLK);
-			s3c2410_gpio_cfgpin(S3C2410_GPE6, S3C2410_GPE6_SDCMD);
-			s3c2410_gpio_cfgpin(S3C2410_GPE7, S3C2410_GPE7_SDDAT0);
-			s3c2410_gpio_cfgpin(S3C2410_GPE8, S3C2410_GPE8_SDDAT1);
-			s3c2410_gpio_cfgpin(S3C2410_GPE9, S3C2410_GPE9_SDDAT2);
-			s3c2410_gpio_cfgpin(S3C2410_GPE10, S3C2410_GPE10_SDDAT3);
+	switch (ios->power_mode) {
+	case MMC_POWER_ON:
+	case MMC_POWER_UP:
+#ifdef CONFIG_MACH_TOMTOMGO
+		IO_Deactivate(SDCLK);
+		IO_SetFunction(SDCMD);
+		IO_SetFunction(SDDATA0);
+		IO_SetFunction(SDDATA1);
+		IO_SetFunction(SDDATA2);
+		IO_SetFunction(SDDATA3);
 
-			if (host->pdata->set_power)
-				(host->pdata->set_power)(1);
+		IO_Activate(SD_PWR_ON);
+		IO_SetFunction(SDCLK);
+#else
+		s3c2410_gpio_cfgpin(S3C2410_GPE5, S3C2410_GPE5_SDCLK);
+		s3c2410_gpio_cfgpin(S3C2410_GPE6, S3C2410_GPE6_SDCMD);
+		s3c2410_gpio_cfgpin(S3C2410_GPE7, S3C2410_GPE7_SDDAT0);
+		s3c2410_gpio_cfgpin(S3C2410_GPE8, S3C2410_GPE8_SDDAT1);
+		s3c2410_gpio_cfgpin(S3C2410_GPE9, S3C2410_GPE9_SDDAT2);
+		s3c2410_gpio_cfgpin(S3C2410_GPE10, S3C2410_GPE10_SDDAT3);
+#endif
 
+		if (!host->is2440)
 			sdi_con|= S3C2410_SDICON_FIFORESET;
-			break;
+		break;
 
-		case MMC_POWER_OFF:
-		default:
-			if (host->pdata->set_power)
-				(host->pdata->set_power)(0);
-			break;
+	case MMC_POWER_OFF:
+	default:
+#ifdef CONFIG_MACH_TOMTOMGO
+		IO_Deactivate(SDCLK);
+		IO_Deactivate(SDCMD);
+		IO_Deactivate(SDDATA0);
+		IO_Deactivate(SDDATA1);
+		IO_Deactivate(SDDATA2);
+		IO_Deactivate(SDDATA3);
+		IO_Deactivate(SD_PWR_ON);
+#else
+		s3c2410_gpio_setpin(S3C2410_GPE5, 0);
+		s3c2410_gpio_cfgpin(S3C2410_GPE5, S3C2410_GPE5_OUTP);
+#endif
+		if (host->is2440)
+			sdi_con|=S3C2440_SDICON_SDRESET;
+		break;
 	}
 
 	/* Set clock */
-	for(sdi_psc=0;sdi_psc<255;sdi_psc++) {
-		if( (clk_get_rate(host->clk) / (2*(sdi_psc+1))) <= ios->clock) break;
+	for (sdi_psc = 0; sdi_psc < 255; sdi_psc++) {
+		host->real_rate = (clk_get_rate(host->clk) / 
+					(((host->is2440)?1:2)*(sdi_psc+1)));
+		if (host->real_rate <= ios->clock)
+			break;
 	}
 
-	if(sdi_psc > 255) sdi_psc = 255;
-	if (sdi_psc < 8) sdi_psc = 8;
-	writel(sdi_psc, host->base + S3C2410_SDIPRE);
-
+	if (sdi_psc > 255) 
+		sdi_psc = 255;
+	host->prescaler = sdi_psc;
+	
+	writel(host->prescaler, host->base + S3C2410_SDIPRE);
+	//writel(0xff, host->base + S3C2410_SDIPRE);
+	
+	/* If requested clock is 0, real_rate will be 0, too */
+	if (ios->clock == 0)
+		host->real_rate = 0;
+	
 	/* Set CLOCK_ENABLE */
-	if(ios->clock) 	sdi_con |= S3C2410_SDICON_CLOCKTYPE;
-	else		sdi_con &=~S3C2410_SDICON_CLOCKTYPE;
+	if (ios->clock)
+		sdi_con |= S3C2410_SDICON_CLOCKTYPE;
+	else
+		sdi_con &= ~S3C2410_SDICON_CLOCKTYPE;
 
 	writel(sdi_con, host->base + S3C2410_SDICON);
+	
+	if ((ios->power_mode==MMC_POWER_ON) ||
+	    (ios->power_mode==MMC_POWER_UP)) {
+		CONFDBG("SD/MMC slot is running at %lukHz (requested: %ukHz).\n", 
+		host->real_rate/1000, ios->clock/1000);	
+	} else
+		CONFDBG("SD/MMC slot is powered down.\n");
+}
 
-	host->bus_width = ios->bus_width;
+static void s3c2410sdi_reset(struct s3c2410sdi_host *host)
+{
+	u32 con = readl(host->base + S3C2410_SDICON);
 
+	con |= S3C2440_SDICON_SDRESET;
+	
+	writel(con, host->base + S3C2410_SDICON);
 }
 
-static int s3c2410sdi_get_ro(struct mmc_host *mmc)
+/* FIXME: move this in platform-specific function */
+static int qt2410_get_ro(struct mmc_host *host)
 {
-	struct s3c2410sdi_host *host = mmc_priv(mmc);
-	if (s3c2410_gpio_getpin(host->pdata->gpio_wprotect) != 0)
-		return 1;
-	else
-		return 0;
-}	
+	int ret = s3c2410_gpio_getpin(S3C2410_GPH8);
+	return ret ? 1 : 0;
+}
 
 static struct mmc_host_ops s3c2410sdi_ops = {
 	.request	= s3c2410sdi_request,
 	.set_ios	= s3c2410sdi_set_ios,
-	.get_ro		= s3c2410sdi_get_ro,
+	.get_ro		= qt2410_get_ro, 
 };
 
-static void s3c2410_mmc_def_setpower(unsigned int to)
-{
-	s3c2410_gpio_cfgpin(S3C2410_GPA17, S3C2410_GPIO_OUTPUT);
-	s3c2410_gpio_setpin(S3C2410_GPA17, to);
-}
-
-static struct s3c24xx_mmc_platdata s3c2410_mmc_defplat = {
-	.gpio_detect	= S3C2410_GPF2,
-	.set_power	= s3c2410_mmc_def_setpower,
-	.f_max		= 3000000,
-	.ocr_avail	= MMC_VDD_32_33,
-};
-
-static int s3c2410sdi_probe(struct platform_device *pdev)
+static int s3c24xxsdi_probe(struct device *dev, int have_2440)
 {
+	struct platform_device	*pdev = to_platform_device(dev);
 	struct mmc_host 	*mmc;
-	s3c24xx_mmc_pdata_t	*pdata;
 	struct s3c2410sdi_host 	*host;
 
-
 	int ret;
 
-	mmc = mmc_alloc_host(sizeof(struct s3c2410sdi_host), &pdev->dev);
+	mmc = mmc_alloc_host(sizeof(struct s3c2410sdi_host), dev);
 	if (!mmc) {
 		ret = -ENOMEM;
 		goto probe_out;
@@ -564,26 +1073,19 @@
 	host = mmc_priv(mmc);
 
 	spin_lock_init( &host->complete_lock );
+	host->is2440		= have_2440;
+	host->fix2410		= !have_2440;
+	host->dodma		= 0;
 	host->complete_what 	= COMPLETION_NONE;
+	host->pio_active 	= XFER_NONE;
+
 	host->mmc 		= mmc;
 	host->dma		= S3C2410SDI_DMA;
-
-	pdata = pdev->dev.platform_data;
-	if (!pdata) {
-		pdev->dev.platform_data = &s3c2410_mmc_defplat;
-		pdata = &s3c2410_mmc_defplat;
-	}
-
-	host->pdata = pdata;
-
-	host->irq_cd = s3c2410_gpio_getirq(pdata->gpio_detect);
-	s3c2410_gpio_cfgpin(pdata->gpio_detect, S3C2410_GPIO_IRQ);
-	if (pdata->gpio_wprotect)
-		s3c2410_gpio_cfgpin(pdata->gpio_wprotect, S3C2410_GPIO_INPUT);
-
+	host->irq_cd		= IRQ_EINT2;
+	
 	host->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!host->mem) {
-		printk(KERN_ERR PFX "failed to get io memory region resouce.\n");
+		ERR("failed to get io memory region resouce.\n");
 		ret = -ENOENT;
 		goto probe_free_host;
 	}
@@ -592,99 +1094,107 @@
 		RESSIZE(host->mem), pdev->name);
 
 	if (!host->mem) {
-		printk(KERN_ERR PFX "failed to request io memory region.\n");
+		ERR("failed to request io memory region.\n");
 		ret = -ENOENT;
 		goto probe_free_host;
 	}
 
 	host->base = ioremap(host->mem->start, RESSIZE(host->mem));
 	if (host->base == 0) {
-		printk(KERN_ERR PFX "failed to ioremap() io memory region.\n");
+		ERR("failed to ioremap() io memory region.\n");
 		ret = -EINVAL;
 		goto probe_free_mem_region;
 	}
 
 	host->irq = platform_get_irq(pdev, 0);
 	if (host->irq == 0) {
-		printk(KERN_ERR PFX "failed to get interrupt resouce.\n");
+		ERR("failed to get interrupt resouce.\n");
 		ret = -EINVAL;
 		goto probe_iounmap;
 	}
 
-	if(request_irq(host->irq, s3c2410sdi_irq, 0, DRIVER_NAME, host)) {
-		printk(KERN_ERR PFX "failed to request sdi interrupt.\n");
+	if (request_irq(host->irq, s3c2410sdi_irq, 0, DRIVER_NAME, host)) {
+		ERR("failed to request sdi interrupt.\n");
 		ret = -ENOENT;
 		goto probe_iounmap;
 	}
-
+	
+	disable_irq(host->irq);
+	
+#ifdef CONFIG_MACH_TOMTOMGO
+	IO_SetInterruptOnToggle(CD_SD);
+#else
+	s3c2410_gpio_cfgpin(S3C2410_GPF2, S3C2410_GPF2_EINT2);
 	set_irq_type(host->irq_cd, IRQT_BOTHEDGE);
-	if(request_irq(host->irq_cd, s3c2410sdi_irq_cd, 0, DRIVER_NAME, host)) {
-		printk(KERN_ERR PFX "failed to request card detect interrupt.\n" );
+#endif
+
+	if (request_irq(host->irq_cd, s3c2410sdi_irq_cd, 0, DRIVER_NAME, host)) {
+		ERR("failed to request card detect interrupt.\n" );
 		ret = -ENOENT;
 		goto probe_free_irq;
 	}
 
-	if(s3c2410_dma_request(S3C2410SDI_DMA, &s3c2410sdi_dma_client, NULL)) {
-		printk(KERN_ERR PFX "unable to get DMA channel.\n" );
+	if (s3c2410_dma_request(S3C2410SDI_DMA, &s3c2410sdi_dma_client, NULL)) {
+		ERR("unable to get DMA channel.\n" );
 		ret = -EBUSY;
 		goto probe_free_irq_cd;
 	}
 
-	host->clk = clk_get(&pdev->dev, "sdi");
+	host->clk = clk_get(dev, "sdi");
 	if (IS_ERR(host->clk)) {
-		printk(KERN_ERR PFX "failed to find clock source.\n");
+		ERR("failed to find clock source.\n");
 		ret = PTR_ERR(host->clk);
 		host->clk = NULL;
 		goto probe_free_host;
 	}
 
-	if((ret = clk_enable(host->clk))) {
-		printk(KERN_ERR PFX "failed to enable clock source.\n");
+#if 0
+	if ((ret = clk_use(host->clk))) {
+		ERR("failed to use clock source.\n");
+		goto clk_free;
+	}
+#endif
+
+	if ((ret = clk_enable(host->clk))) {
+		ERR("failed to enable clock source.\n");
 		goto clk_unuse;
 	}
 
 
 	mmc->ops 	= &s3c2410sdi_ops;
-	mmc->ocr_avail	= pdata->ocr_avail;
-	mmc->f_min 	= clk_get_rate(host->clk) / 512;
-	mmc->f_max 	= clk_get_rate(host->clk) / 2;
-	mmc->caps	= MMC_CAP_4_BIT_DATA;
-
-	if(pdata->f_max && (mmc->f_max>pdata->f_max))
-		mmc->f_max = pdata->f_max;
-
-	/*
-	 * Since we only have a 16-bit data length register, we must
-	 * ensure that we don't exceed 2^16-1 bytes in a single request.
-	 * Choose 64 (512-byte) sectors as the limit.
-	 */
-	mmc->max_sectors = 64;
+	mmc->ocr_avail	= MMC_VDD_32_33;
+	//mmc->caps	= MMC_CAP_4_BIT_DATA;
+	mmc->f_min 	= clk_get_rate(host->clk) / (((host->is2440)?1:2) * 256);
+	mmc->f_max 	= clk_get_rate(host->clk) / ((host->is2440)?1:2);
 
-	/*
-	 * Set the maximum segment size.  Since we aren't doing DMA
-	 * (yet) we are only limited by the data length register.
-	 */
-
-	mmc->max_seg_size = mmc->max_sectors << 9;
-	printk(KERN_INFO PFX "probe: mapped sdi_base=%p irq=%u irq_cd=%u \n",
-		host->base, host->irq, host->irq_cd);
+	mmc->max_sectors	= 4095;
+	mmc->max_seg_size	= mmc->max_sectors << 9;
+	
+	mmc->max_phys_segs	= 128;
+	mmc->max_hw_segs	= 128;
+	
+	DBG("probe: mode:%s fix2410:%s mapped sdi_base=%p irq=%u irq_cd=%u "
+	    "dma=%u.\n", (host->is2440?"2440":"2410"), 
+	    (host->fix2410?"enabled":"disabled"),
+	    host->base, host->irq, host->irq_cd, host->dma);
 
-	if((ret = mmc_add_host(mmc))) {
-		printk(KERN_ERR PFX "failed to add mmc host.\n");
-		goto clk_disable;
+	if ((ret = mmc_add_host(mmc))) {
+		ERR("failed to add mmc host.\n");
+		goto free_dmabuf;
 	}
 
-	platform_set_drvdata(pdev, mmc);
+	dev_set_drvdata(dev, mmc);
 
-	mmc_detect_change(mmc, 0);
-
-	printk(KERN_INFO PFX "initialisation done.\n");
+	INFO("initialisation done.\n");
 	return 0;
-	
- clk_disable:
+
+ free_dmabuf:
 	clk_disable(host->clk);
 
  clk_unuse:
+	//clk_unuse(host->clk);
+
+ clk_free:
 	clk_put(host->clk);
 
  probe_free_irq_cd:
@@ -705,13 +1215,14 @@
 	return ret;
 }
 
-static int s3c2410sdi_remove(struct platform_device *pdev)
+static int s3c2410sdi_remove(struct device *dev)
 {
-	struct mmc_host 	*mmc  = platform_get_drvdata(pdev);
+	struct mmc_host 	*mmc  = dev_get_drvdata(dev);
 	struct s3c2410sdi_host 	*host = mmc_priv(mmc);
 
 	mmc_remove_host(mmc);
 	clk_disable(host->clk);
+	//clk_unuse(host->clk);
 	clk_put(host->clk);
  	free_irq(host->irq_cd, host);
  	free_irq(host->irq, host);
@@ -722,71 +1233,96 @@
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int s3c2410mci_suspend(struct platform_device *dev, pm_message_t state)
-{
-	struct mmc_host *mmc = platform_get_drvdata(dev);
-	struct s3c2410sdi_host  *host;
-	int ret = 0;
-
-	if (mmc) {
-		host = mmc_priv(mmc);
+/* FIXME: This is a coarse hack. Selection of mode should be done by adding different
+ *        devices (s3c2410-sdi or s3c2440-sdi) to the platform bus. */
 
-		ret = mmc_suspend_host(mmc, state);
+static int s3c24xxsdi_probe_cpuid(struct device *dev)
+{
+	u32 idcode = __raw_readl(S3C2410_GSTATUS1) & S3C2410_GSTATUS1_IDMASK;
+	switch (idcode) {
+		case S3C2410_GSTATUS1_2410:
+			return s3c24xxsdi_probe(dev, 0);
 
-		clk_disable(host->clk);
+		case S3C2410_GSTATUS1_2440:
+			return s3c24xxsdi_probe(dev, 1);
 
-		disable_irq(host->irq_cd);
-		disable_irq(host->irq);
+		default:
+			ERR("unkonown CPUID (0x%08x). Can't load driver.\n", idcode);
 	}
+	return -ENOENT;
+}
 
-	return ret;
+#if 0
+static int s3c2410sdi_probe(struct device *dev)
+{
+	return s3c24xxsdi_probe(dev, 0);
 }
 
-static int s3c2410mci_resume(struct platform_device *dev)
+static int s3c2440sdi_probe(struct device *dev)
 {
-	struct mmc_host *mmc = platform_get_drvdata(dev);
-	struct s3c2410sdi_host  *host;
-	int ret = 0;
+	return s3c24xxsdi_probe(dev, 1);
+}
+#endif
 
-	if (mmc) {
-		host = mmc_priv(mmc);
+#ifdef CONFIG_PM
+static int s3c24XXsdi_suspend(struct device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	int ret = 0;
 
-		enable_irq(host->irq_cd);
-		enable_irq(host->irq);
+	if (mmc)
+		ret = mmc_suspend_host(mmc, state);
 
-		clk_enable(host->clk);
+	return ret;
+}
 
+static int s3c24XXsdi_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	int ret = 0;
+	
+	if (mmc)
 		ret = mmc_resume_host(mmc);
-	}
 
 	return ret;
 }
 #else
-#define s3c2410mci_suspend	NULL
-#define s3c2410mci_resume	NULL
+#define s3c24XXsdi_suspend NULL
+#define s3c24XXsdi_resume NULL
 #endif
 
-static struct platform_driver s3c2410sdi_driver =
+static struct device_driver s3c2410sdi_driver =
+{
+        .name           = "s3c2410-sdi",
+        .bus            = &platform_bus_type,
+        .probe          = s3c24xxsdi_probe_cpuid,
+        .remove         = s3c2410sdi_remove,
+		.suspend		= s3c24XXsdi_suspend,
+		.resume			= s3c24XXsdi_resume,
+};
+
+static struct device_driver s3c2440sdi_driver =
 {
-	.driver		= {
-        	.name	= "s3c2410-sdi",
-		.owner	= THIS_MODULE,
-	},
-        .probe          = s3c2410sdi_probe,
+        .name           = "s3c2440-sdi",
+        .bus            = &platform_bus_type,
+        .probe          = s3c24xxsdi_probe_cpuid,
         .remove         = s3c2410sdi_remove,
-	.suspend	= s3c2410mci_suspend,
-	.resume		= s3c2410mci_resume,
+		.suspend		= s3c24XXsdi_suspend,
+		.resume			= s3c24XXsdi_resume,
 };
 
+
 static int __init s3c2410sdi_init(void)
 {
-	return platform_driver_register(&s3c2410sdi_driver);
+	driver_register(&s3c2410sdi_driver);
+	driver_register(&s3c2440sdi_driver);
+	return 0;
 }
 
 static void __exit s3c2410sdi_exit(void)
 {
-	platform_driver_unregister(&s3c2410sdi_driver);
+	driver_unregister(&s3c2410sdi_driver);
+	driver_unregister(&s3c2440sdi_driver);
 }
 
 module_init(s3c2410sdi_init);
@@ -794,3 +1330,4 @@
 
 MODULE_DESCRIPTION("Samsung S3C2410 Multimedia Card Interface driver");
 MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Thomas Kleffel <tk@maintech.de>");
Index: linux-2.6.17.7-new/drivers/mmc/s3c2410mci.h
===================================================================
--- linux-2.6.17.7-new.orig/drivers/mmc/s3c2410mci.h	2006-08-07 17:35:41.000000000 +0200
+++ linux-2.6.17.7-new/drivers/mmc/s3c2410mci.h	2006-08-07 17:38:53.000000000 +0200
@@ -10,10 +10,9 @@
 
 struct clk;
 
+//FIXME: DMA Resource management ?!
 #define S3C2410SDI_DMA 0
 
-#define S3C2410SDI_CDLATENCY 50
-
 enum s3c2410sdi_waitfor {
 	COMPLETION_NONE,
 	COMPLETION_CMDSENT,
@@ -22,11 +21,8 @@
 	COMPLETION_XFERFINISH_RSPFIN,
 };
 
-typedef struct s3c24xx_mmc_platdata s3c24xx_mmc_pdata_t;
-
 struct s3c2410sdi_host {
 	struct mmc_host		*mmc;
-	s3c24xx_mmc_pdata_t	*pdata;
 
 	struct resource		*mem;
 	struct clk		*clk;
@@ -34,22 +30,35 @@
 	int			irq;
 	int			irq_cd;
 	int			dma;
+	
+	unsigned long		real_rate;
+	u8			prescaler;
+
+	int			is2440;
+	int			fix2410;
+	int			dodma;
 
-	struct scatterlist*	cur_sg;		/* Current SG entry */
-	unsigned int		num_sg;		/* Number of entries left */
-	void*			mapped_sg;	/* vaddr of mapped sg */
-
-	unsigned int		offset;		/* Offset into current entry */
-	unsigned int		remain;		/* Data left in curren entry */
-
-	int			size;		/* Total size of transfer */
+	volatile int		dmatogo;
 
 	struct mmc_request	*mrq;
-
-	unsigned char		bus_width;	/* Current bus width */
+	int			cmd_is_stop;
 
 	spinlock_t		complete_lock;
-	struct completion	complete_request;
-	struct completion	complete_dma;
-	enum s3c2410sdi_waitfor	complete_what;
+	volatile enum s3c2410sdi_waitfor	
+				complete_what;
+		
+	volatile int		dma_complete;
+	
+	u32			pio_sgptr;
+	u32			pio_words;
+	u32			*pio_ptr;
+#define XFER_NONE 0
+#define XFER_READ 1
+#define XFER_WRITE 2
+	u32			pio_active;
+	
+	char 			dbgmsg_cmd[301];
+	char 			dbgmsg_dat[301];
+
+	unsigned int		ccnt, dcnt;	
 };
Index: linux-2.6.17.7-new/include/asm-arm/arch-s3c2410/dma.h
===================================================================
--- linux-2.6.17.7-new.orig/include/asm-arm/arch-s3c2410/dma.h	2006-08-07 17:35:41.000000000 +0200
+++ linux-2.6.17.7-new/include/asm-arm/arch-s3c2410/dma.h	2006-08-07 17:38:53.000000000 +0200
@@ -189,6 +189,7 @@
 	unsigned long          dev_addr;
 	unsigned long          load_timeout;
 	unsigned int           flags;        /* channel flags */
+	unsigned int           hwsrc;
 
 	/* channel's hardware position and configuration */
 	void __iomem           *regs;        /* channels registers */
@@ -275,7 +276,8 @@
 */
 
 extern int s3c2410_dma_devconfig(int channel, s3c2410_dmasrc_t source,
-				 int hwcfg, unsigned long devaddr);
+				 int hwcfg, unsigned long devaddr,
+				 unsigned int hwsrc);
 
 /* s3c2410_dma_getposition
  *
Index: linux-2.6.17.7-new/include/asm-arm/arch-s3c2410/regs-sdi.h
===================================================================
--- linux-2.6.17.7-new.orig/include/asm-arm/arch-s3c2410/regs-sdi.h	2006-08-07 17:35:41.000000000 +0200
+++ linux-2.6.17.7-new/include/asm-arm/arch-s3c2410/regs-sdi.h	2006-08-07 17:38:53.000000000 +0200
@@ -18,6 +18,7 @@
 #ifndef __ASM_ARM_REGS_SDI
 #define __ASM_ARM_REGS_SDI "regs-sdi.h"
 
+#define S3C2410_SDIREG(x)       ((x) + S3C24XX_VA_SDI)
 #define S3C2410_SDICON                (0x00)
 #define S3C2410_SDIPRE                (0x04)
 #define S3C2410_SDICMDARG             (0x08)
@@ -33,9 +34,16 @@
 #define S3C2410_SDIDCNT               (0x30)
 #define S3C2410_SDIDSTA               (0x34)
 #define S3C2410_SDIFSTA               (0x38)
+
+//This is REALLY ugly!
 #define S3C2410_SDIDATA               (0x3C)
 #define S3C2410_SDIIMSK               (0x40)
 
+#define S3C2440_SDIDATA               (0x40)
+#define S3C2440_SDIIMSK               (0x3C)
+
+#define S3C2440_SDICON_SDRESET        (1<<8)
+#define S3C2440_SDICON_MMCCLOCK       (1<<5)
 #define S3C2410_SDICON_BYTEORDER      (1<<4)
 #define S3C2410_SDICON_SDIOIRQ        (1<<3)
 #define S3C2410_SDICON_RWAITEN        (1<<2)
@@ -57,6 +65,9 @@
 #define S3C2410_SDICMDSTAT_XFERING    (1<<8)
 #define S3C2410_SDICMDSTAT_INDEX      (0xff)
 
+#define S3C2440_SDIDCON_DS_BYTE       (0<<22)
+#define S3C2440_SDIDCON_DS_HALFWORD   (1<<22)
+#define S3C2440_SDIDCON_DS_WORD       (2<<22)
 #define S3C2410_SDIDCON_IRQPERIOD     (1<<21)
 #define S3C2410_SDIDCON_TXAFTERRESP   (1<<20)
 #define S3C2410_SDIDCON_RXAFTERCMD    (1<<19)
@@ -65,6 +76,7 @@
 #define S3C2410_SDIDCON_WIDEBUS       (1<<16)
 #define S3C2410_SDIDCON_DMAEN         (1<<15)
 #define S3C2410_SDIDCON_STOP          (1<<14)
+#define S3C2440_SDIDCON_DATSTART      (1<<14)
 #define S3C2410_SDIDCON_DATMODE	      (3<<12)
 #define S3C2410_SDIDCON_BLKNUM        (0x7ff)
 
@@ -89,10 +101,12 @@
 #define S3C2410_SDIDSTA_TXDATAON      (1<<1)
 #define S3C2410_SDIDSTA_RXDATAON      (1<<0)
 
+#define S3C2440_SDIFSTA_FIFORESET      (1<<16)
+#define S3C2440_SDIFSTA_FIFOFAIL       (3<<14)  /* 3 is correct (2 bits) */
 #define S3C2410_SDIFSTA_TFDET          (1<<13)
 #define S3C2410_SDIFSTA_RFDET          (1<<12)
-#define S3C2410_SDIFSTA_TXHALF         (1<<11)
-#define S3C2410_SDIFSTA_TXEMPTY        (1<<10)
+#define S3C2410_SDIFSTA_TFHALF         (1<<11)
+#define S3C2410_SDIFSTA_TFEMPTY        (1<<10)
 #define S3C2410_SDIFSTA_RFLAST         (1<<9)
 #define S3C2410_SDIFSTA_RFFULL         (1<<8)
 #define S3C2410_SDIFSTA_RFHALF         (1<<7)
